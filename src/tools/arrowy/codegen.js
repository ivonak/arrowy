import { PARAM_KEYS } from './useArrowyRenderer';

export function generateJS({ values, features, breakpoints, style, draw }) {
  const hasResponsive = features.responsive;
  const hasScroll = features.scroll;
  const bp = breakpoints;
  const s = style;
  const d = draw;

  const fmtObj = (obj) => {
    const entries = Object.entries(obj).map(([k,v]) => `${k}: ${v}`).join(', ');
    return `{ ${entries} }`;
  };

  let code = `/**
 * Custom LeaderLine implementation
 * Generated by Arrowy - Leader Line Tuning Tool
 */

const DEFAULT_OPTIONS = {
  color: '${s.color1}',
  gradientColors: ['${s.color1}', '${s.color2}'],
  strokeWidth: ${s.strokeWidth},
  dashArray: '${s.dashLen} ${s.dashGap}',
  arrowSize: ${s.arrowSize},
  drawDuration: ${d.duration},
  drawColor: '${d.useGradient ? '' : d.color}',
  drawStrokeWidth: ${d.strokeWidth},
  drawOpacity: ${d.opacity},
  startOffset: [20, 20],
  endAnchor: [0.5, 0.5],
  observeMutations: false,
};

export function createLeaderLine(startElement, endElement, options = {}) {
  const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
  const normalizeDashArray = (value) => {
    if (typeof value !== 'string') return DEFAULT_OPTIONS.dashArray;
    const match = value.trim().match(/^(\\d+(?:\\.\\d+)?)\\s+(\\d+(?:\\.\\d+)?)$/);
    return match ? \`\${match[1]} \${match[2]}\` : DEFAULT_OPTIONS.dashArray;
  };
  const normalizeTuple = (value, fallback) => {
    if (!Array.isArray(value) || value.length !== 2) return fallback;
    const a = Number(value[0]), b = Number(value[1]);
    if (!Number.isFinite(a) || !Number.isFinite(b)) return fallback;
    return [a, b];
  };
  const rawOpts = { ...DEFAULT_OPTIONS, ...options };
  const opts = {
    ...rawOpts,
    gradientColors: Array.isArray(rawOpts.gradientColors) && rawOpts.gradientColors.length === 2
      ? [String(rawOpts.gradientColors[0]), String(rawOpts.gradientColors[1])]
      : DEFAULT_OPTIONS.gradientColors,
    strokeWidth: Math.max(0.5, Number(rawOpts.strokeWidth) || DEFAULT_OPTIONS.strokeWidth),
    dashArray: normalizeDashArray(rawOpts.dashArray),
    arrowSize: Math.max(1, Number(rawOpts.arrowSize) || DEFAULT_OPTIONS.arrowSize),
    drawDuration: Math.max(0, Number(rawOpts.drawDuration) || DEFAULT_OPTIONS.drawDuration),
    drawColor: typeof rawOpts.drawColor === 'string' ? rawOpts.drawColor : DEFAULT_OPTIONS.drawColor,
    drawStrokeWidth: Math.max(0.5, Number(rawOpts.drawStrokeWidth) || DEFAULT_OPTIONS.drawStrokeWidth),
    drawOpacity: clamp(Number(rawOpts.drawOpacity), 0, 1),
    startOffset: normalizeTuple(rawOpts.startOffset, DEFAULT_OPTIONS.startOffset),
    endAnchor: normalizeTuple(rawOpts.endAnchor, DEFAULT_OPTIONS.endAnchor),
    observeMutations: Boolean(rawOpts.observeMutations),
  };

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  const uniqueId = \`leader-line-\${Date.now()}-\${Math.random().toString(36).substr(2, 9)}\`;
  svg.setAttribute('class', 'custom-leader-line');
  svg.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1000;overflow:visible;';

  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
  gradient.setAttribute('id', \`\${uniqueId}-gradient\`);
  gradient.setAttribute('gradientUnits', 'userSpaceOnUse');
  const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
  stop1.setAttribute('offset', '0%'); stop1.setAttribute('stop-color', opts.gradientColors[0]);
  const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
  stop2.setAttribute('offset', '100%'); stop2.setAttribute('stop-color', opts.gradientColors[1]);
  gradient.appendChild(stop1); gradient.appendChild(stop2);
  defs.appendChild(gradient); svg.appendChild(defs);

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke', \`url(#\${uniqueId}-gradient)\`);
  path.setAttribute('stroke-width', opts.strokeWidth.toString());
  path.setAttribute('stroke-linecap', 'round');
  path.setAttribute('stroke-linejoin', 'round');
  svg.appendChild(path);

  const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  arrow.setAttribute('fill', 'none');
  arrow.setAttribute('stroke', opts.gradientColors[0]);
  arrow.setAttribute('stroke-width', opts.strokeWidth.toString());
  arrow.setAttribute('stroke-linecap', 'round');
  arrow.setAttribute('stroke-linejoin', 'round');
  arrow.style.opacity = '0';
  svg.appendChild(arrow);
  document.body.appendChild(svg);

  let needsDrawAnimation = true;
  let wasHidden = false;
  let destroyed = false;
  let frameId = 0;
  let drawTimeoutId = 0;
`;

  if (hasResponsive) {
    code += `\n  const valuesAtMin = ${fmtObj(values.min)};\n  const valuesAtMax = ${fmtObj(values.max)};\n`;
  } else {
    code += `\n  const baseValues = ${fmtObj(values.min)};\n`;
  }
  if (hasScroll) {
    code += `  const valuesAtScroll = ${fmtObj(values.scroll)};\n`;
  }
  if (hasResponsive) {
    code += `\n  const MIN_WIDTH = ${bp.minWidth};\n  const GROW_START = ${bp.growStart};\n  const MAX_WIDTH = ${bp.maxWidth};\n`;
  } else {
    code += `\n  const MIN_WIDTH = ${bp.minWidth};\n`;
  }
  if (hasScroll) {
    code += `  const SCROLL_START_INTERPOLATE = ${bp.scrollStart};\n  const SCROLL_HIDE_THRESHOLD = ${bp.scrollHide};\n`;
  }

  code += `
  const lerp = (start, end, progress) => Math.round(start + (end - start) * progress);
`;

  if (hasResponsive) {
    code += `
  const getResponsiveValues = () => {
    const width = window.innerWidth;
    if (width < MIN_WIDTH || width <= GROW_START) return { ...valuesAtMin };
    const progress = Math.min((width - GROW_START) / (MAX_WIDTH - GROW_START), 1);
    return {
${PARAM_KEYS.map(k => `      ${k}: lerp(valuesAtMin.${k}, valuesAtMax.${k}, progress),`).join('\n')}
    };
  };
`;
  }

  code += `
  function updatePosition() {
    if (destroyed) return;
    if (window.innerWidth < MIN_WIDTH) { svg.style.display = 'none'; wasHidden = true; return; }
    const startRect = startElement.getBoundingClientRect();
    if (startRect.width === 0 || startRect.height === 0) { svg.style.display = 'none'; wasHidden = true; return; }
`;

  if (hasScroll) {
    code += `    if (startRect.top < SCROLL_HIDE_THRESHOLD) { svg.style.display = 'none'; wasHidden = true; return; }
    if (wasHidden) {
      if (startRect.top > SCROLL_START_INTERPOLATE) { wasHidden = false; needsDrawAnimation = true; arrow.style.opacity = '0'; }
      else { svg.style.display = 'none'; return; }
    }
`;
  } else {
    code += `    if (wasHidden) { wasHidden = false; needsDrawAnimation = true; arrow.style.opacity = '0'; }
`;
  }

  code += `    svg.style.display = ''; svg.style.opacity = '1';
`;

  if (hasScroll) {
    code += `    let scrollProgress = 0;
    if (startRect.top < SCROLL_START_INTERPOLATE) {
      scrollProgress = Math.min(Math.max((SCROLL_START_INTERPOLATE - startRect.top) / (SCROLL_START_INTERPOLATE - SCROLL_HIDE_THRESHOLD), 0), 1);
    }
    svg.style.opacity = (1 - scrollProgress * 0.7).toString();
`;
  }

  if (hasResponsive) code += `    const baseValues = getResponsiveValues();\n`;

  if (hasScroll) {
    code += `    const controls = {
${PARAM_KEYS.map(k => `      ${k}: lerp(baseValues.${k}, valuesAtScroll.${k}, scrollProgress),`).join('\n')}
    };
`;
  } else {
    code += `    const controls = baseValues;\n`;
  }

  const arrowAngleRad = `(${s.arrowAngle} * Math.PI / 180)`;

  code += `
    const startX = startRect.left + opts.startOffset[0];
    const startY = startRect.top + opts.startOffset[1];
    const endRect = endElement.getBoundingClientRect();
    const endX = endRect.left + endRect.width * opts.endAnchor[0];
    const endY = endRect.top + endRect.height * opts.endAnchor[1];
    gradient.setAttribute('x1', endX); gradient.setAttribute('y1', endY);
    gradient.setAttribute('x2', startX); gradient.setAttribute('y2', startY);

    const loopX = (startX + endX) / 2 + controls.loopX;
    const loopY = (startY + endY) / 2 + controls.loopY;
    const entry1X = startX + controls.e1X, entry1Y = startY + controls.e1Y;
    const entry2X = loopX + controls.e2X, entry2Y = loopY + controls.e2Y;
    const loopCp1X = loopX + controls.l1X, loopCp1Y = loopY + controls.l1Y;
    const loopCp2X = loopX + controls.l2X, loopCp2Y = loopY + controls.l2Y;
    const loopExitX = loopX + controls.exitX, loopExitY = loopY + controls.exitY;
    const exit1X = loopExitX + controls.x1X, exit1Y = loopExitY + controls.x1Y;
    const exit2X = endX + controls.x2X, exit2Y = endY + controls.x2Y;

    path.setAttribute('d', \`M \${startX} \${startY} C \${entry1X} \${entry1Y}, \${entry2X} \${entry2Y}, \${loopX} \${loopY} C \${loopCp1X} \${loopCp1Y}, \${loopCp2X} \${loopCp2Y}, \${loopExitX} \${loopExitY} C \${exit1X} \${exit1Y}, \${exit2X} \${exit2Y}, \${endX} \${endY}\`);

    if (needsDrawAnimation) {
      needsDrawAnimation = false;
      const pathLength = path.getTotalLength();
      if (opts.drawColor) path.setAttribute('stroke', opts.drawColor);
      path.setAttribute('stroke-width', opts.drawStrokeWidth.toString());
      path.style.opacity = opts.drawOpacity.toString();
      path.style.transition = 'none';
      path.style.strokeDasharray = \`\${pathLength}\`;
      path.style.strokeDashoffset = \`\${pathLength}\`;
      path.getBoundingClientRect();
      path.style.transition = \`stroke-dashoffset \${opts.drawDuration}s ease-out\`;
      path.style.strokeDashoffset = '0';
      drawTimeoutId = window.setTimeout(() => {
        if (destroyed) return;
        path.style.transition = 'none';
        path.setAttribute('stroke', \`url(#\${uniqueId}-gradient)\`);
        path.setAttribute('stroke-width', opts.strokeWidth.toString());
        path.style.opacity = '1';
        path.style.strokeDasharray = opts.dashArray;
        path.style.strokeDashoffset = '0';
        arrow.setAttribute('stroke-dasharray', opts.dashArray);
        arrow.style.transition = 'opacity 0.3s ease-out';
        arrow.style.opacity = '1';
      }, opts.drawDuration * 1000 + 50);
    }

    const arrowAngle = ${arrowAngleRad};
    const tangentAngle = Math.atan2(exit2Y - endY, exit2X - endX);
    const a1x = endX + opts.arrowSize * Math.cos(tangentAngle - arrowAngle);
    const a1y = endY + opts.arrowSize * Math.sin(tangentAngle - arrowAngle);
    const a2x = endX + opts.arrowSize * Math.cos(tangentAngle + arrowAngle);
    const a2y = endY + opts.arrowSize * Math.sin(tangentAngle + arrowAngle);
    arrow.setAttribute('d', \`M \${a1x} \${a1y} L \${endX} \${endY} L \${a2x} \${a2y}\`);
  }

  const scheduleUpdate = () => { if (destroyed || frameId) return; frameId = requestAnimationFrame(() => { frameId = 0; updatePosition(); }); };
  updatePosition();
  const handler = () => scheduleUpdate();
  const findScrollParent = (element) => {
    let parent = element.parentElement;
    while (parent) {
      const style = getComputedStyle(parent);
      if (style.overflow === 'auto' || style.overflow === 'scroll' || style.overflowY === 'auto' || style.overflowY === 'scroll') return parent;
      parent = parent.parentElement;
    }
    return window;
  };
  const scrollParent = findScrollParent(startElement);
  const passiveOptions = { passive: true };
  window.addEventListener('resize', handler);
  if (scrollParent === window) window.addEventListener('scroll', handler, passiveOptions);
  else scrollParent.addEventListener('scroll', handler, passiveOptions);

  const resizeObserver = new ResizeObserver(() => scheduleUpdate());
  resizeObserver.observe(startElement); resizeObserver.observe(endElement);
  const mutationObserver = opts.observeMutations ? new MutationObserver(() => scheduleUpdate()) : null;
  if (mutationObserver) mutationObserver.observe(document.body, { attributes: true, childList: true, subtree: true });

  return {
    remove: () => {
      if (destroyed) return; destroyed = true;
      if (frameId) { cancelAnimationFrame(frameId); frameId = 0; }
      if (drawTimeoutId) clearTimeout(drawTimeoutId);
      window.removeEventListener('resize', handler);
      if (scrollParent !== window) scrollParent.removeEventListener('scroll', handler);
      else window.removeEventListener('scroll', handler);
      resizeObserver.disconnect();
      if (mutationObserver) mutationObserver.disconnect();
      svg.remove();
    },
    position: scheduleUpdate,
  };
}

export function useLeaderLine() { return { createLeaderLine }; }
`;

  return code;
}

const MINIFY_URL = 'https://cdn.jsdelivr.net/npm/terser@5.39.0/dist/bundle.min.js';
let terserLoad = null;

function ensureTerser() {
  if (window.Terser) return Promise.resolve();
  if (terserLoad) return terserLoad;
  terserLoad = new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = MINIFY_URL;
    s.async = true;
    s.onload = resolve;
    s.onerror = () => reject(new Error('Failed to load minifier'));
    document.head.appendChild(s);
  });
  return terserLoad;
}

export async function generateMinifiedJS(state) {
  const source = generateJS(state);
  try {
    await ensureTerser();
    const result = await window.Terser.minify(source, {
      module: true, compress: true, mangle: true, format: { comments: false },
    });
    if (result?.code) return result.code;
  } catch {}
  return source;
}
