import { vertexSrc, fragmentSrc } from './shaders';

export function generateReadableJS(config) {
  const c = config;
  return `/**
 * Grid Background Effect
 * Generated by Grid Playground
 *
 * CSS gradient (add to your container):
 *   background: linear-gradient(135deg, ${c.bgStart} 0%, ${c.bgMid} 50%, ${c.bgEnd} 100%);
 */

const VERTEX_SRC = ${JSON.stringify(vertexSrc)};
const FRAGMENT_SRC = ${JSON.stringify(fragmentSrc)};

export function createGridBackground(container, options = {}) {
  const config = {
    dotColor: '${c.dotColor}',
    dotOpacity: ${c.dotOpacity},
    dotFinalOpacity: ${c.dotFinalOpacity},
    gridSpacing: ${c.gridSpacing},
    dotSize: ${c.dotSize},
    influenceRadius: ${c.influenceRadius},
    shapeType: ${JSON.stringify(c.shapeType)},
    shapeStretchX: ${c.shapeStretchX},
    shapeStretchY: ${c.shapeStretchY},
    blobSeed: ${c.blobSeed},
    blobLobes: ${c.blobLobes},
    blobJaggedness: ${c.blobJaggedness},
    blobScale: ${c.blobScale},
    ballRoundness: ${c.ballRoundness},
    compressionStrength: ${c.compressionStrength},
    dotSeparation: ${c.dotSeparation},
    dotSharpness: ${c.dotSharpness},
    grainEnabled: ${c.grainEnabled},
    grainAmount: ${c.grainAmount},
    grainBackColor: '${c.grainBackColor}',
    grainFrontColor: '${c.grainFrontColor}',
    grainBackOpacity: ${c.grainBackOpacity},
    grainFrontOpacity: ${c.grainFrontOpacity},
    grainBgMode: '${c.grainBgMode}',
    grainBlendMode: '${c.grainBlendMode}',
    grainSpread: ${c.grainSpread},
    grainPresence: ${c.grainPresence},
    grainCoverage: ${c.grainCoverage},
    grainBreakup: ${c.grainBreakup},
    grainThreshold: ${c.grainThreshold},
    grainContrast: ${c.grainContrast},
    grainLift: ${c.grainLift},
    grainGamma: ${c.grainGamma},
    grainDither: ${c.grainDither},
    grainBias: ${c.grainBias},
    grainOffset: ${c.grainOffset},
    grainEdgeSoftness: ${c.grainEdgeSoftness},
    grainIntensity: ${c.grainIntensity},
    grainRadialFalloff: ${c.grainRadialFalloff},
    grainEdgeSteepness: ${c.grainEdgeSteepness},
    grainDensityScale: ${c.grainDensityScale},
    grainFalloffOnset: ${c.grainFalloffOnset},
    motionSpeed: ${c.motionSpeed},
    waveAmount: ${c.waveAmount},
    ...options,
  };

  const SHAPE_MAP = { circle: 0, ellipse: 1, roundedSquare: 2, randomBlob: 3 };

  function hexToRgb01(hex) {
    const n = hex.replace('#', '');
    const v = n.length === 3 ? n.split('').map(c => c + c).join('') : n;
    const num = parseInt(v, 16);
    return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];
  }

  function clamp(n, lo, hi) { return Math.min(hi, Math.max(lo, n)); }

  const canvas = document.createElement('canvas');
  canvas.style.cssText = 'position:absolute;inset:0;width:100%;height:100%;display:block;pointer-events:none;';
  container.style.position = container.style.position || 'relative';
  container.appendChild(canvas);

  const gl = canvas.getContext('webgl', { antialias: true, alpha: true, premultipliedAlpha: false });
  if (!gl) { console.error('WebGL required'); return { destroy() {} }; }

  function compileShader(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s;
  }

  const vs = compileShader(VERTEX_SRC, gl.VERTEX_SHADER);
  const fs = compileShader(FRAGMENT_SRC, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);

  const posLoc = gl.getAttribLocation(program, 'a_pos');
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.clearColor(0, 0, 0, 0);

  const u = {};
  ['u_resolution','u_contact','u_dir','u_dotColor','u_dotBaseOpacity','u_dotFinalOpacity',
   'u_gridSpacing','u_dotSize','u_influenceRadius','u_shapeType','u_shapeStretchX','u_shapeStretchY',
   'u_blobSeed','u_blobLobes','u_blobJaggedness','u_blobScale','u_ballRoundness',
   'u_compressionStrength','u_dotSeparation','u_dotSharpness',
   'u_grainAmount','u_grainBackColor','u_grainFrontColor','u_grainBackOpacity','u_grainFrontOpacity',
   'u_grainBgMode','u_grainBlendMode','u_grainPresence','u_grainCoverage','u_grainBreakup',
   'u_grainThreshold','u_grainContrast','u_grainLift','u_grainGamma','u_grainDither',
   'u_grainBias','u_grainOffset','u_grainEdgeSoftness',
   'u_grainIntensity','u_grainRadialFalloff','u_grainEdgeSteepness',
   'u_grainDensityScale','u_grainFalloffOnset'
  ].forEach(n => { u[n] = gl.getUniformLocation(program, n); });

  const seeds = { x1: Math.random()*10, x2: Math.random()*10 };
  const motion = { x: 0, y: 0, vx: 0, vy: 0, lastX: 0, lastY: 0 };
  let lastMs = 0, dpr = 1, rafId = 0, destroyed = false;

  function resize() {
    dpr = Math.min(window.devicePixelRatio || 1, 1.5);
    const w = container.clientWidth, h = container.clientHeight;
    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    gl.viewport(0, 0, canvas.width, canvas.height);
    motion.x = w * 0.5; motion.y = h * 0.5;
  }

  function frame(ms) {
    if (destroyed) return;
    const cfg = config;
    const w = container.clientWidth, h = container.clientHeight;
    if (!w || !h) { rafId = requestAnimationFrame(frame); return; }
    const dt = lastMs ? clamp((ms - lastMs) / 1000, 0.001, 0.05) : 1/60;
    lastMs = ms;

    const speed = 0.05 + Math.pow(cfg.motionSpeed, 1.45) * 0.95;
    const t = ms / 1000 * speed;
    const orbit = t * 0.9 + seeds.x1, drift = t * 0.43 + seeds.x2;
    const tx = w*0.5 + Math.cos(orbit)*w*0.2 + Math.cos(orbit*0.52+drift)*w*cfg.waveAmount*0.55;
    const ty = h*0.5 + Math.sin(orbit*0.92+0.35)*h*0.18 + Math.sin(orbit*0.47+drift+1.1)*h*cfg.waveAmount*0.55;
    motion.lastX = motion.x; motion.lastY = motion.y;
    const blend = 1 - Math.exp(-8.8 * dt);
    motion.x += (tx - motion.x) * blend; motion.y += (ty - motion.y) * blend;
    const ivx = (motion.x - motion.lastX) / Math.max(0.001, dt);
    const ivy = (motion.y - motion.lastY) / Math.max(0.001, dt);
    motion.vx = motion.vx * 0.78 + ivx * 0.22;
    motion.vy = motion.vy * 0.78 + ivy * 0.22;
    const spd = Math.hypot(motion.vx, motion.vy);
    const dirX = spd > 0.0001 ? motion.vx/spd : 1;
    const dirY = spd > 0.0001 ? motion.vy/spd : 0;

    const dotC = hexToRgb01(cfg.dotColor);
    const gbC = hexToRgb01(cfg.grainBackColor);
    const gfC = hexToRgb01(cfg.grainFrontColor);
    const spread = clamp(cfg.grainSpread, 0, 1.5), spreadN = spread / 1.5;

    gl.useProgram(program);
    gl.uniform2f(u.u_resolution, canvas.width, canvas.height);
    gl.uniform2f(u.u_contact, motion.x*dpr, (h-motion.y)*dpr);
    gl.uniform2f(u.u_dir, dirX, -dirY);
    gl.uniform3f(u.u_dotColor, ...dotC);
    gl.uniform1f(u.u_dotBaseOpacity, cfg.dotOpacity);
    gl.uniform1f(u.u_dotFinalOpacity, cfg.dotFinalOpacity);
    gl.uniform1f(u.u_gridSpacing, cfg.gridSpacing * dpr);
    gl.uniform1f(u.u_dotSize, cfg.dotSize * dpr);
    gl.uniform1f(u.u_influenceRadius, cfg.influenceRadius * dpr);
    gl.uniform1f(u.u_shapeType, SHAPE_MAP[cfg.shapeType] ?? 0);
    gl.uniform1f(u.u_shapeStretchX, cfg.shapeStretchX);
    gl.uniform1f(u.u_shapeStretchY, cfg.shapeStretchY);
    gl.uniform1f(u.u_blobSeed, cfg.blobSeed);
    gl.uniform1f(u.u_blobLobes, cfg.blobLobes);
    gl.uniform1f(u.u_blobJaggedness, cfg.blobJaggedness);
    gl.uniform1f(u.u_blobScale, cfg.blobScale);
    gl.uniform1f(u.u_ballRoundness, cfg.ballRoundness);
    gl.uniform1f(u.u_compressionStrength, cfg.compressionStrength);
    gl.uniform1f(u.u_dotSeparation, cfg.dotSeparation);
    gl.uniform1f(u.u_dotSharpness, cfg.dotSharpness);
    gl.uniform1f(u.u_grainAmount, cfg.grainEnabled ? cfg.grainAmount : 0.0);
    gl.uniform3f(u.u_grainBackColor, ...gbC);
    gl.uniform3f(u.u_grainFrontColor, ...gfC);
    gl.uniform1f(u.u_grainBackOpacity, cfg.grainBackOpacity);
    gl.uniform1f(u.u_grainFrontOpacity, cfg.grainFrontOpacity);
    gl.uniform1f(u.u_grainBgMode, cfg.grainBgMode === 'light' ? 1 : 0);
    gl.uniform1f(u.u_grainBlendMode, {normal:0,screen:1,add:2,multiply:3}[cfg.grainBlendMode] ?? 0);
    gl.uniform1f(u.u_grainPresence, clamp(cfg.grainPresence*(1+spreadN*0.32),0,2));
    gl.uniform1f(u.u_grainCoverage, clamp(cfg.grainCoverage*(1+spreadN*1.25),0.5,2.5));
    gl.uniform1f(u.u_grainBreakup, clamp(cfg.grainBreakup*(1+spreadN*0.22),0,1.5));
    gl.uniform1f(u.u_grainThreshold, clamp(cfg.grainThreshold*(1-spreadN*0.16),0.6,1.2));
    gl.uniform1f(u.u_grainContrast, cfg.grainContrast);
    gl.uniform1f(u.u_grainLift, cfg.grainLift);
    gl.uniform1f(u.u_grainGamma, cfg.grainGamma);
    gl.uniform1f(u.u_grainDither, clamp(cfg.grainDither*(1+spreadN*0.35),0,5));
    gl.uniform1f(u.u_grainBias, cfg.grainBias);
    gl.uniform1f(u.u_grainOffset, cfg.grainOffset);
    gl.uniform1f(u.u_grainEdgeSoftness, clamp(cfg.grainEdgeSoftness+spreadN*0.22,0,1));
    gl.uniform1f(u.u_grainIntensity, cfg.grainIntensity);
    gl.uniform1f(u.u_grainRadialFalloff, cfg.grainRadialFalloff);
    gl.uniform1f(u.u_grainEdgeSteepness, cfg.grainEdgeSteepness);
    gl.uniform1f(u.u_grainDensityScale, cfg.grainDensityScale);
    gl.uniform1f(u.u_grainFalloffOnset, cfg.grainFalloffOnset);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    rafId = requestAnimationFrame(frame);
  }

  resize();
  window.addEventListener('resize', resize);
  rafId = requestAnimationFrame(frame);

  return {
    destroy() {
      destroyed = true;
      cancelAnimationFrame(rafId);
      window.removeEventListener('resize', resize);
      canvas.remove();
    }
  };
}
`;
}

const MINIFY_URL = 'https://cdn.jsdelivr.net/npm/terser@5.39.0/dist/bundle.min.js';
let terserLoad = null;

function ensureTerser() {
  if (window.Terser) return Promise.resolve();
  if (terserLoad) return terserLoad;
  terserLoad = new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = MINIFY_URL;
    s.async = true;
    s.onload = resolve;
    s.onerror = () => reject(new Error('Failed to load minifier'));
    document.head.appendChild(s);
  });
  return terserLoad;
}

export async function generateMinifiedJS(config) {
  const source = generateReadableJS(config);
  try {
    await ensureTerser();
    const result = await window.Terser.minify(source, {
      module: true, compress: true, mangle: true, format: { comments: false },
    });
    if (result?.code) return result.code;
  } catch {}
  return source;
}
