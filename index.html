<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Arrowy - Leader Line Tuning Tool</title>
<style>
  :root {
    --panel-width: 318px;
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
    color: #e0e0e0;
    min-height: 100vh;
    overflow: hidden;
  }

  /* Dot grid background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: radial-gradient(circle, rgba(255,255,255,0.06) 1px, transparent 1px);
    background-size: 24px 24px;
    pointer-events: none;
    z-index: 0;
  }

  #canvas {
    position: fixed;
    top: 0;
    left: 0;
    right: var(--panel-width);
    bottom: 0;
    z-index: 1;
  }

  /* Subtle anchor demo elements (object anchoring preview) */
  #demoStage {
    position: fixed;
    left: calc((100vw - var(--panel-width)) / 2);
    top: 50%;
    transform: translate(-50%, -50%);
    width: min(88vw, calc(100vw - var(--panel-width) - 32px), 768px);
    height: min(48vh, 360px);
    z-index: 2;
    pointer-events: none;
  }
  .anchor-rect {
    position: absolute;
    width: clamp(80px, 12vw, 130px);
    height: clamp(54px, 8vw, 82px);
    border-radius: 24px;
    backdrop-filter: blur(8px);
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 8px 28px rgba(0,0,0,0.2);
    opacity: 0.72;
  }
  #anchorStartEl {
    left: 8px;
    top: calc(50% - 220px);
    transform: translateY(-50%);
  }
  #anchorEndEl {
    right: 8px;
    top: calc(50% + 120px);
    transform: translateY(-50%);
  }

  body.dragging, body.dragging * { cursor: grabbing !important; }

  /* SVG layer */
  #lineSvg {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
    overflow: visible;
  }

  /* Panel */
  #panel {
    position: fixed;
    top: 0;
    right: 0;
    width: var(--panel-width);
    height: 100vh;
    background: rgba(15, 17, 30, 0.9);
    backdrop-filter: blur(10px);
    border-left: 1px solid rgba(255,255,255,0.06);
    z-index: 100;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .panel-header {
    padding: 12px 14px 10px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    flex-shrink: 0;
  }
  .panel-header h1 {
    font-size: 14px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 2px;
  }
  .panel-header p {
    font-size: 10px;
    color: rgba(255,255,255,0.35);
  }

  .panel-body {
    flex: 1;
    overflow-y: auto;
    padding: 0 0 70px 0;
  }
  .panel-body::-webkit-scrollbar { width: 5px; }
  .panel-body::-webkit-scrollbar-track { background: transparent; }
  .panel-body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }

  /* Sections */
  .section {
    border-bottom: 1px solid rgba(255,255,255,0.05);
  }
  .section-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 14px;
    cursor: pointer;
    user-select: none;
    transition: background 0.15s;
  }
  .section-header:hover { background: rgba(255,255,255,0.03); }
  .section-title {
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: rgba(255,255,255,0.5);
  }
  .section-chevron {
    font-size: 10px;
    color: rgba(255,255,255,0.3);
    transition: transform 0.2s;
  }
  .section.collapsed .section-chevron { transform: rotate(-90deg); }
  .section-content {
    padding: 0 14px 10px;
  }
  .section.collapsed .section-content { display: none; }

  /* Toggle switch */
  .toggle-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 0;
  }
  .toggle-label { font-size: 11px; color: rgba(255,255,255,0.68); }
  .toggle-switch {
    width: 22px;
    height: 12px;
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.05);
    border-radius: 999px;
    position: relative;
    cursor: pointer;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .toggle-switch.on {
    background: rgba(152, 203, 79, 0.38);
  }
  .toggle-switch::after {
    content: '';
    position: absolute;
    width: 10px;
    height: 10px;
    background: rgba(255,255,255,0.7);
    border-radius: 50%;
    top: 0;
    left: 0;
    transition: transform 0.2s;
  }
  .toggle-switch.on::after { transform: translateX(12px); }

  /* Tabs */
  .tabs {
    display: flex;
    padding: 0 18px;
    gap: 2px;
    margin-bottom: 10px;
  }
  .tab {
    flex: 1;
    padding: 7px 8px;
    font-size: 11px;
    font-weight: 600;
    text-align: center;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 6px;
    cursor: pointer;
    color: rgba(255,255,255,0.45);
    transition: all 0.15s;
    user-select: none;
  }
  .tab:hover { background: rgba(255,255,255,0.08); }
  .tab.active {
    background: rgba(152, 203, 79, 0.15);
    border-color: rgba(152, 203, 79, 0.3);
    color: #98CB4F;
  }

  /* Slider rows */
  .slider-group {
    margin-bottom: 8px;
  }
  .slider-group-title {
    font-size: 11px;
    font-weight: 600;
    color: rgba(255,255,255,0.35);
    margin-bottom: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .slider-group-title .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    display: inline-block;
  }
  .slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 3px;
  }
  .slider-row label {
    font-size: 11px;
    color: rgba(255,255,255,0.5);
    width: 20px;
    flex-shrink: 0;
    text-align: right;
  }
  .slider-row input[type="range"] {
    flex: 1;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    outline: none;
  }
  .slider-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #98CB4F;
    cursor: pointer;
  }
  .slider-row input[type="number"] {
    width: 48px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    color: #e0e0e0;
    font-size: 11px;
    padding: 3px 5px;
    text-align: center;
    flex-shrink: 0;
  }
  .slider-row input[type="number"]:focus {
    outline: none;
    border-color: rgba(152, 203, 79, 0.4);
  }

  /* Breakpoint inputs */
  .bp-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  .bp-row label {
    font-size: 11px;
    color: rgba(255,255,255,0.5);
  }
  .bp-row input {
    width: 70px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    color: #e0e0e0;
    font-size: 11px;
    padding: 4px 6px;
    text-align: center;
  }
  .bp-row input:focus { outline: none; border-color: rgba(152,203,79,0.4); }

  /* Color picker row */
  .color-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  .color-row label { font-size: 11px; color: rgba(255,255,255,0.5); }
  .color-row input[type="color"] {
    width: 32px;
    height: 24px;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 4px;
    background: none;
    cursor: pointer;
    padding: 0;
  }
  .color-row input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
  .color-row input[type="color"]::-webkit-color-swatch { border-radius: 2px; border: none; }

  /* Toolbar */
  .toolbar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 8px 14px;
    background: rgba(10, 12, 22, 0.95);
    border-top: 1px solid rgba(255,255,255,0.08);
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    z-index: 101;
  }
  .btn {
    padding: 6px 12px;
    font-size: 11px;
    font-weight: 600;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s;
    background: rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.7);
  }
  .btn:hover { background: rgba(255,255,255,0.12); color: #fff; }
  .btn.primary {
    background: rgba(152, 203, 79, 0.2);
    border-color: rgba(152, 203, 79, 0.3);
    color: #98CB4F;
  }
  .btn.primary:hover { background: rgba(152, 203, 79, 0.35); }
  .btn.small { padding: 3px 7px; font-size: 10px; }

  /* Checkbox row */
  .check-row {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 4px;
  }
  .check-row input[type="checkbox"] { accent-color: #98CB4F; }
  .check-row label { font-size: 11px; color: rgba(255,255,255,0.5); cursor: pointer; }

  /* Anchor controls */
  .anchor-block {
    margin-bottom: 8px;
    padding: 12px 0;
    display: grid;
    grid-template-columns: auto minmax(0, 1fr);
    grid-template-rows: auto auto auto;
    gap: 6px 18px;
    align-items: start;
  }
  .anchor-block-title {
    font-size: 10px;
    color: rgba(255,255,255,0.5);
    margin-bottom: 0;
    letter-spacing: 0.4px;
    grid-column: 1 / -1;
  }
  .anchor-grid {
    display: grid;
    grid-template-columns: repeat(3, 14px);
    grid-template-rows: repeat(3, 14px);
    gap: 3px;
    margin-bottom: 0;
    grid-column: 1;
    grid-row: 2 / 4;
  }
  .anchor-dot {
    width: 14px;
    height: 14px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.05);
    cursor: pointer;
    transition: all 0.15s;
  }
  .anchor-dot:hover { background: rgba(255,255,255,0.1); }
  .anchor-dot.active {
    background: rgba(152, 203, 79, 0.22);
    border-color: rgba(152, 203, 79, 0.6);
  }
  .offset-row {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 5px;
    margin-bottom: 0;
  }
  .anchor-block .offset-row:nth-of-type(1) { grid-column: 2; grid-row: 2; }
  .anchor-block .offset-row:nth-of-type(2) { grid-column: 2; grid-row: 3; }
  .offset-row label {
    font-size: 10px;
    color: rgba(255,255,255,0.5);
    white-space: nowrap;
  }
  .offset-row select,
  .offset-row input {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    color: #e0e0e0;
    font-size: 10px;
    padding: 3px 5px;
  }
  .offset-row select { width: 58px; }
  .offset-row input { width: 48px; text-align: center; }

  /* Modal */
  .modal-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 200;
    align-items: center;
    justify-content: center;
  }
  .modal-backdrop.visible { display: flex; }
  .modal {
    background: #1a1c2e;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px;
    width: 90vw;
    max-width: 800px;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .modal-header h2 { font-size: 15px; color: #fff; }
  .code-editor-shell {
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 16px;
    background: #0d0f1a;
  }
  .code-editor-toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: transparent;
  }
  .code-mode-tabs {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .code-mode-btn {
    padding: 3px 1px;
    font-size: 11px;
    border: none;
    background: transparent;
    color: rgba(255,255,255,0.65);
    cursor: pointer;
    position: relative;
  }
  .code-mode-btn::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: -3px;
    height: 1px;
    border-radius: 2px;
    background: transparent;
  }
  .code-mode-btn.active {
    color: #fff;
    font-weight: 500;
  }
  .code-mode-btn.active::after {
    background: #98CB4F;
  }
  .copy-icon-btn {
    width: 26px;
    height: 26px;
    border-radius: 6px;
    border: none;
    background: transparent;
    color: rgba(255,255,255,0.7);
    cursor: pointer;
    display: grid;
    place-items: center;
  }
  .copy-icon-btn:hover { background: rgba(255,255,255,0.08); color: #fff; }
  .copy-icon-btn svg {
    width: 14px;
    height: 14px;
    stroke: currentColor;
    fill: none;
    stroke-width: 1.8;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .modal-close {
    background: none;
    border: none;
    color: rgba(255,255,255,0.4);
    font-size: 20px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
  }
  .modal-close:hover { color: #fff; background: rgba(255,255,255,0.08); }
  .modal-body {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
  }
  .modal-body::-webkit-scrollbar { width: 5px; }
  .modal-body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }
  .code-block {
    background: transparent;
    padding: 16px;
    overflow-x: auto;
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    font-size: 12px;
    line-height: 1.5;
    color: #c9d1d9;
    white-space: pre;
    max-height: 30vh;
    overflow-y: auto;
  }
  .code-block::-webkit-scrollbar { width: 5px; height: 5px; }
  .code-block::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }
  .usage-section h3 {
    font-size: 13px;
    color: #98CB4F;
    margin-bottom: 8px;
  }
  .usage-section p, .usage-section li {
    font-size: 12px;
    color: rgba(255,255,255,0.65);
    line-height: 1.6;
  }
  .usage-section code {
    background: rgba(255,255,255,0.06);
    padding: 1px 5px;
    border-radius: 3px;
    font-family: 'SF Mono', monospace;
    font-size: 11px;
    color: #e0e0e0;
  }
  .usage-section ol { padding-left: 20px; margin-bottom: 12px; }
  .usage-section li { margin-bottom: 4px; }

  /* Toast */
  .toast {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(60px);
    background: #1a1c2e;
    border: 1px solid rgba(152,203,79,0.3);
    color: #98CB4F;
    padding: 8px 20px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 600;
    z-index: 300;
    transition: transform 0.3s ease;
    pointer-events: none;
  }
  .toast.show { transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>

<!-- Canvas area -->
<div id="canvas"></div>

<!-- Anchor demo stage -->
<div id="demoStage" aria-hidden="true">
  <div id="anchorStartEl" class="anchor-rect"></div>
  <div id="anchorEndEl" class="anchor-rect"></div>
</div>

<!-- SVG layer -->
<svg id="lineSvg">
  <defs>
    <linearGradient id="lineGradient" gradientUnits="userSpaceOnUse">
      <stop offset="0%" stop-color="#98CB4F" />
      <stop offset="100%" stop-color="#41A0AA" />
    </linearGradient>
  </defs>
  <g id="handleLines"></g>
  <path id="mainPath" fill="none" stroke="url(#lineGradient)" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="6 6" />
  <path id="arrowPath" fill="none" stroke="#98CB4F" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" />
  <g id="debugDots"></g>
</svg>

<!-- Panel -->
<div id="panel">
  <div class="panel-header">
    <h1>Arrowy</h1>
    <p>Leader Line Tuning Tool</p>
  </div>

  <div class="panel-body">

    <!-- Feature toggles -->
    <div class="section">
      <div class="section-header" onclick="toggleSection(this)">
        <span class="section-title">Features</span>
        <span class="section-chevron">&#9660;</span>
      </div>
      <div class="section-content">
        <div class="toggle-row">
          <span class="toggle-label">Responsive scaling</span>
          <div class="toggle-switch on" id="toggleResponsive" onclick="toggleFeature('responsive')"></div>
        </div>
        <div class="toggle-row">
          <span class="toggle-label">Scroll interpolation</span>
          <div class="toggle-switch on" id="toggleScroll" onclick="toggleFeature('scroll')"></div>
        </div>
        <div class="toggle-row">
          <span class="toggle-label">Show dots</span>
          <div class="toggle-switch on" id="toggleDots" onclick="toggleFeature('dots')"></div>
        </div>
        <div class="toggle-row">
          <span class="toggle-label">Show handle lines</span>
          <div class="toggle-switch on" id="toggleHandles" onclick="toggleFeature('handles')"></div>
        </div>
        <div class="toggle-row">
          <span class="toggle-label">Show start/end handles</span>
          <div class="toggle-switch on" id="toggleEndpoints" onclick="toggleFeature('endpoints')"></div>
        </div>
      </div>
    </div>

    <!-- Handle positions -->
    <div class="section collapsed">
      <div class="section-header" onclick="toggleSection(this)">
        <span class="section-title">Anchors</span>
        <span class="section-chevron">&#9660;</span>
      </div>
      <div class="section-content">
        <div class="anchor-block">
          <div class="anchor-block-title">START ELEMENT ANCHOR</div>
          <input type="hidden" id="startAnchorPoint" value="cc">
          <div class="anchor-grid" id="startAnchorGrid">
            <button class="anchor-dot" data-anchor-point="tl" onclick="onAnchorPointSelect('start','tl')"></button>
            <button class="anchor-dot" data-anchor-point="tc" onclick="onAnchorPointSelect('start','tc')"></button>
            <button class="anchor-dot" data-anchor-point="tr" onclick="onAnchorPointSelect('start','tr')"></button>
            <button class="anchor-dot" data-anchor-point="cl" onclick="onAnchorPointSelect('start','cl')"></button>
            <button class="anchor-dot active" data-anchor-point="cc" onclick="onAnchorPointSelect('start','cc')"></button>
            <button class="anchor-dot" data-anchor-point="cr" onclick="onAnchorPointSelect('start','cr')"></button>
            <button class="anchor-dot" data-anchor-point="bl" onclick="onAnchorPointSelect('start','bl')"></button>
            <button class="anchor-dot" data-anchor-point="bc" onclick="onAnchorPointSelect('start','bc')"></button>
            <button class="anchor-dot" data-anchor-point="br" onclick="onAnchorPointSelect('start','br')"></button>
          </div>
          <div class="offset-row">
            <label>X offset</label>
            <select id="startOffsetXSide" onchange="onAnchorConfigChange('start')">
              <option value="left" selected>left</option>
              <option value="right">right</option>
            </select>
            <input type="number" id="startOffsetXValue" value="0" onchange="onAnchorConfigChange('start')">
          </div>
          <div class="offset-row">
            <label>Y offset</label>
            <select id="startOffsetYSide" onchange="onAnchorConfigChange('start')">
              <option value="top" selected>top</option>
              <option value="bottom">bottom</option>
            </select>
            <input type="number" id="startOffsetYValue" value="0" onchange="onAnchorConfigChange('start')">
          </div>
        </div>

        <div class="anchor-block">
          <div class="anchor-block-title">END ELEMENT ANCHOR</div>
          <input type="hidden" id="endAnchorPoint" value="cc">
          <div class="anchor-grid" id="endAnchorGrid">
            <button class="anchor-dot" data-anchor-point="tl" onclick="onAnchorPointSelect('end','tl')"></button>
            <button class="anchor-dot" data-anchor-point="tc" onclick="onAnchorPointSelect('end','tc')"></button>
            <button class="anchor-dot" data-anchor-point="tr" onclick="onAnchorPointSelect('end','tr')"></button>
            <button class="anchor-dot" data-anchor-point="cl" onclick="onAnchorPointSelect('end','cl')"></button>
            <button class="anchor-dot active" data-anchor-point="cc" onclick="onAnchorPointSelect('end','cc')"></button>
            <button class="anchor-dot" data-anchor-point="cr" onclick="onAnchorPointSelect('end','cr')"></button>
            <button class="anchor-dot" data-anchor-point="bl" onclick="onAnchorPointSelect('end','bl')"></button>
            <button class="anchor-dot" data-anchor-point="bc" onclick="onAnchorPointSelect('end','bc')"></button>
            <button class="anchor-dot" data-anchor-point="br" onclick="onAnchorPointSelect('end','br')"></button>
          </div>
          <div class="offset-row">
            <label>X offset</label>
            <select id="endOffsetXSide" onchange="onAnchorConfigChange('end')">
              <option value="left" selected>left</option>
              <option value="right">right</option>
            </select>
            <input type="number" id="endOffsetXValue" value="0" onchange="onAnchorConfigChange('end')">
          </div>
          <div class="offset-row">
            <label>Y offset</label>
            <select id="endOffsetYSide" onchange="onAnchorConfigChange('end')">
              <option value="top" selected>top</option>
              <option value="bottom">bottom</option>
            </select>
            <input type="number" id="endOffsetYValue" value="0" onchange="onAnchorConfigChange('end')">
          </div>
        </div>
      </div>
    </div>

    <!-- Breakpoints -->
    <div class="section collapsed" id="breakpointsSection">
      <div class="section-header" onclick="toggleSection(this)">
        <span class="section-title">Breakpoints</span>
        <span class="section-chevron">&#9660;</span>
      </div>
      <div class="section-content">
        <div class="bp-row">
          <label>MIN_WIDTH</label>
          <input type="number" id="bpMinWidth" value="992" onchange="onBreakpointChange()">
        </div>
        <div class="bp-row">
          <label>GROW_START</label>
          <input type="number" id="bpGrowStart" value="1280" onchange="onBreakpointChange()">
        </div>
        <div class="bp-row">
          <label>MAX_WIDTH</label>
          <input type="number" id="bpMaxWidth" value="1920" onchange="onBreakpointChange()">
        </div>
        <div class="bp-row" id="scrollBpRow1">
          <label>SCROLL_START</label>
          <input type="number" id="bpScrollStart" value="250" onchange="onBreakpointChange()">
        </div>
        <div class="bp-row" id="scrollBpRow2">
          <label>SCROLL_HIDE</label>
          <input type="number" id="bpScrollHide" value="180" onchange="onBreakpointChange()">
        </div>
      </div>
    </div>

    <!-- Value set tabs -->
    <div class="section">
      <div class="section-header" onclick="toggleSection(this)">
        <span class="section-title">Curve Parameters</span>
        <span class="section-chevron">&#9660;</span>
      </div>
      <div class="section-content" style="padding-top:4px">
        <div class="tabs" id="valueTabs"></div>
        <div id="slidersContainer"></div>
      </div>
    </div>

    <!-- Style settings -->
    <div class="section">
      <div class="section-header" onclick="toggleSection(this)">
        <span class="section-title">Line Style</span>
        <span class="section-chevron">&#9660;</span>
      </div>
      <div class="section-content">
        <div class="color-row">
          <label>Gradient color 1</label>
          <input type="color" id="styleColor1" value="#98CB4F" oninput="onStyleChange()">
        </div>
        <div class="color-row">
          <label>Gradient color 2</label>
          <input type="color" id="styleColor2" value="#41A0AA" oninput="onStyleChange()">
        </div>
        <div class="slider-row">
          <label>W</label>
          <input type="range" min="1" max="10" step="0.5" value="3" id="styleStrokeWidth" oninput="onStyleChange()">
          <input type="number" min="1" max="10" step="0.5" value="3" id="styleStrokeWidthNum" onchange="syncStyleSlider('strokeWidth')">
        </div>
        <div class="slider-row">
          <label style="font-size:9px">Dash</label>
          <input type="range" min="1" max="30" step="1" value="6" id="styleDashLen" oninput="onStyleChange()">
          <input type="number" min="1" max="30" step="1" value="6" id="styleDashLenNum" onchange="syncStyleSlider('dashLen')">
        </div>
        <div class="slider-row">
          <label style="font-size:9px">Gap</label>
          <input type="range" min="1" max="30" step="1" value="6" id="styleDashGap" oninput="onStyleChange()">
          <input type="number" min="1" max="30" step="1" value="6" id="styleDashGapNum" onchange="syncStyleSlider('dashGap')">
        </div>
        <div class="slider-row">
          <label style="font-size:9px">Head</label>
          <input type="range" min="5" max="50" step="1" value="18" id="styleArrowSize" oninput="onStyleChange()">
          <input type="number" min="5" max="50" step="1" value="18" id="styleArrowSizeNum" onchange="syncStyleSlider('arrowSize')">
        </div>
        <div class="slider-row">
          <label style="font-size:9px">Ang</label>
          <input type="range" min="10" max="90" step="1" value="36" id="styleArrowAngle" oninput="onStyleChange()">
          <input type="number" min="10" max="90" step="1" value="36" id="styleArrowAngleNum" onchange="syncStyleSlider('arrowAngle')">
        </div>
        <div class="color-row">
          <label>Arrow head color</label>
          <input type="color" id="styleArrowColor" value="#98CB4F" oninput="onStyleChange()">
        </div>
      </div>
    </div>

    <!-- Draw animation settings -->
    <div class="section collapsed">
      <div class="section-header" onclick="toggleSection(this)">
        <span class="section-title">Draw Animation</span>
        <span class="section-chevron">&#9660;</span>
      </div>
      <div class="section-content">
        <div class="slider-row">
          <label style="font-size:9px">Dur</label>
          <input type="range" min="0.1" max="3" step="0.1" value="0.7" id="drawDuration" oninput="onDrawStyleChange()">
          <input type="number" min="0.1" max="3" step="0.1" value="0.7" id="drawDurationNum" onchange="syncDrawSlider('duration')">
        </div>
        <div class="check-row">
          <input type="checkbox" id="drawUseGradient" checked onchange="onDrawStyleChange()">
          <label for="drawUseGradient">Use gradient during draw</label>
        </div>
        <div class="color-row" id="drawColorRow">
          <label>Draw color</label>
          <input type="color" id="drawColor" value="#98CB4F" oninput="onDrawStyleChange()" disabled>
        </div>
        <div class="slider-row">
          <label>W</label>
          <input type="range" min="1" max="10" step="0.5" value="3" id="drawStrokeWidth" oninput="onDrawStyleChange()">
          <input type="number" min="1" max="10" step="0.5" value="3" id="drawStrokeWidthNum" onchange="syncDrawSlider('strokeWidth')">
        </div>
        <div class="slider-row">
          <label style="font-size:9px">Opa</label>
          <input type="range" min="0" max="1" step="0.05" value="0.4" id="drawOpacity" oninput="onDrawStyleChange()">
          <input type="number" min="0" max="1" step="0.05" value="0.4" id="drawOpacityNum" onchange="syncDrawSlider('opacity')">
        </div>
        <div style="margin-top:8px">
          <button class="btn small" onclick="previewDraw()">Preview Draw Animation</button>
        </div>
      </div>
    </div>

  </div>

  <!-- Toolbar -->
  <div class="toolbar">
    <button class="btn small" onclick="copyAll()">Copy Values</button>
    <button class="btn small primary" onclick="openCodeModal()">Get Code</button>
    <button class="btn small" onclick="resetCurrent()">Reset</button>
  </div>
</div>

<!-- Modal -->
<div class="modal-backdrop" id="modalBackdrop" onclick="closeModal(event)">
  <div class="modal" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h2 id="generatedCodeTitle">Generated Code</h2>
      <div style="display:flex;gap:6px;align-items:center">
        <button class="modal-close" onclick="closeModal()">&times;</button>
      </div>
    </div>
    <div class="modal-body">
      <div class="code-editor-shell">
        <div class="code-editor-toolbar">
          <div class="code-mode-tabs">
            <button id="codeModeReadable" class="code-mode-btn active" onclick="setCodeMode('readable')">Readable JS</button>
            <button id="codeModeMinified" class="code-mode-btn" onclick="setCodeMode('minified')">Minified JS</button>
          </div>
          <button class="copy-icon-btn" onclick="copyGeneratedCode()" title="Copy code" aria-label="Copy code">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <rect x="9" y="9" width="11" height="11" rx="2"></rect>
              <path d="M5 15V6a2 2 0 0 1 2-2h9"></path>
            </svg>
          </button>
        </div>
        <div class="code-block" id="generatedCode"></div>
      </div>
      <div class="usage-section">
        <h3>Quick start</h3>
        <ol>
          <li>Choose <code>Readable JS</code> while integrating (or <code>Minified JS</code> for production), then click the copy icon.</li>
          <li>Save as <code>leaderLine.js</code> in your project.</li>
          <li>Import it where needed: <code>import { createLeaderLine } from './leaderLine';</code></li>
          <li>Create a line between two DOM elements: <code>const line = createLeaderLine(startElement, endElement, options);</code></li>
          <li>Call <code>line.position()</code> after major layout changes if your app does custom transitions/layouting.</li>
          <li>Call <code>line.remove()</code> when unmounting/cleaning up.</li>
        </ol>
        <h3>Options (all optional)</h3>
        <p>Only pass what you need. Defaults are already embedded in the generated code.</p>
        <ol>
          <li><code>gradientColors</code> - Two-color gradient: <code>[startColor, endColor]</code>.</li>
          <li><code>color</code> - Fallback single color when gradient is not used.</li>
          <li><code>strokeWidth</code> - Final line thickness in px.</li>
          <li><code>dashArray</code> - Dash pattern string, e.g. <code>"6 6"</code>.</li>
          <li><code>arrowSize</code> - Arrowhead size in px.</li>
          <li><code>drawDuration</code> - Initial draw animation duration (seconds).</li>
          <li><code>drawColor</code> - Temporary draw color (empty keeps gradient during draw).</li>
          <li><code>drawStrokeWidth</code> - Temporary stroke width during draw phase.</li>
          <li><code>drawOpacity</code> - Temporary opacity during draw phase (0 to 1).</li>
          <li><code>startOffset</code> - Start anchor offset: <code>[x, y]</code> in px.</li>
          <li><code>endAnchor</code> - End anchor ratio inside target element: <code>[0..1, 0..1]</code> (center is <code>[0.5, 0.5]</code>).</li>
          <li><code>observeMutations</code> - Set <code>true</code> if your layout shifts without resize/scroll events.</li>
        </ol>
      </div>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast">Copied!</div>

<script>
// ─── State ──────────────────────────────────────────────────────────
const PARAM_KEYS = ['loopX','loopY','e1X','e1Y','e2X','e2Y','l1X','l1Y','l2X','l2Y','exitX','exitY','x1X','x1Y','x2X','x2Y'];

const PARAM_GROUPS = [
  { name: 'Loop Point', keys: ['loopX','loopY'], color: '#facc15' },
  { name: 'Entry CP1', keys: ['e1X','e1Y'], color: '#ef4444' },
  { name: 'Entry CP2', keys: ['e2X','e2Y'], color: '#f97316' },
  { name: 'Loop CP1', keys: ['l1X','l1Y'], color: '#22c55e' },
  { name: 'Loop CP2', keys: ['l2X','l2Y'], color: '#06b6d4' },
  { name: 'Exit Point', keys: ['exitX','exitY'], color: '#3b82f6' },
  { name: 'Exit CP1', keys: ['x1X','x1Y'], color: '#a855f7' },
  { name: 'Exit CP2', keys: ['x2X','x2Y'], color: '#ec4899' },
];

const DOT_COLORS = {};
PARAM_GROUPS.forEach(g => { g.keys.forEach(k => DOT_COLORS[k] = g.color); });

const defaults = {
  min: { loopX:42, loopY:-33, e1X:28, e1Y:-41, e2X:28, e2Y:5, l1X:-64, l1Y:-10, l2X:-54, l2Y:79, exitX:11, exitY:40, x1X:58, x1Y:-47, x2X:80, x2Y:3 },
  max: { loopX:42, loopY:-21, e1X:-14, e1Y:-41, e2X:28, e2Y:5, l1X:-157, l1Y:-18, l2X:-76, l2Y:119, exitX:13, exitY:51, x1X:58, x1Y:-47, x2X:80, x2Y:-20 },
  scroll: { loopX:21, loopY:-30, e1X:-16, e1Y:-29, e2X:27, e2Y:-15, l1X:-73, l1Y:35, l2X:93, l2Y:62, exitX:-7, exitY:-10, x1X:-47, x1Y:-26, x2X:54, x2Y:-29 },
};

const state = {
  values: {
    min: { ...defaults.min },
    max: { ...defaults.max },
    scroll: { ...defaults.scroll },
  },
  activeTab: 'min',
  features: { responsive: true, scroll: true, dots: true, handles: true, endpoints: true },
  startPos: { x: 0, y: 0 },
  endPos: { x: 0, y: 0 },
};

// ─── Elements ───────────────────────────────────────────────────────
const SVG_NS = 'http://www.w3.org/2000/svg';
const lineSvg = document.getElementById('lineSvg');
const mainPath = document.getElementById('mainPath');
const arrowPath = document.getElementById('arrowPath');
const debugDotsG = document.getElementById('debugDots');
const handleLinesG = document.getElementById('handleLines');
const tabsContainer = document.getElementById('valueTabs');
const slidersContainer = document.getElementById('slidersContainer');
const lineGradient = document.getElementById('lineGradient');
const lineGradientStartStop = lineGradient.querySelector('stop:first-child');
const lineGradientEndStop = lineGradient.querySelector('stop:last-child');
const generatedCodeTitle = document.getElementById('generatedCodeTitle');
const anchorStartEl = document.getElementById('anchorStartEl');
const anchorEndEl = document.getElementById('anchorEndEl');

const els = {
  bpMinWidth: document.getElementById('bpMinWidth'),
  bpGrowStart: document.getElementById('bpGrowStart'),
  bpMaxWidth: document.getElementById('bpMaxWidth'),
  bpScrollStart: document.getElementById('bpScrollStart'),
  bpScrollHide: document.getElementById('bpScrollHide'),
  startAnchorPoint: document.getElementById('startAnchorPoint'),
  startOffsetXSide: document.getElementById('startOffsetXSide'),
  startOffsetXValue: document.getElementById('startOffsetXValue'),
  startOffsetYSide: document.getElementById('startOffsetYSide'),
  startOffsetYValue: document.getElementById('startOffsetYValue'),
  endAnchorPoint: document.getElementById('endAnchorPoint'),
  endOffsetXSide: document.getElementById('endOffsetXSide'),
  endOffsetXValue: document.getElementById('endOffsetXValue'),
  endOffsetYSide: document.getElementById('endOffsetYSide'),
  endOffsetYValue: document.getElementById('endOffsetYValue'),
  styleColor1: document.getElementById('styleColor1'),
  styleColor2: document.getElementById('styleColor2'),
  styleStrokeWidth: document.getElementById('styleStrokeWidth'),
  styleStrokeWidthNum: document.getElementById('styleStrokeWidthNum'),
  styleDashLen: document.getElementById('styleDashLen'),
  styleDashLenNum: document.getElementById('styleDashLenNum'),
  styleDashGap: document.getElementById('styleDashGap'),
  styleDashGapNum: document.getElementById('styleDashGapNum'),
  styleArrowSize: document.getElementById('styleArrowSize'),
  styleArrowSizeNum: document.getElementById('styleArrowSizeNum'),
  styleArrowAngle: document.getElementById('styleArrowAngle'),
  styleArrowAngleNum: document.getElementById('styleArrowAngleNum'),
  styleArrowColor: document.getElementById('styleArrowColor'),
  drawDuration: document.getElementById('drawDuration'),
  drawDurationNum: document.getElementById('drawDurationNum'),
  drawUseGradient: document.getElementById('drawUseGradient'),
  drawColor: document.getElementById('drawColor'),
  drawStrokeWidth: document.getElementById('drawStrokeWidth'),
  drawStrokeWidthNum: document.getElementById('drawStrokeWidthNum'),
  drawOpacity: document.getElementById('drawOpacity'),
  drawOpacityNum: document.getElementById('drawOpacityNum'),
};

const renderState = { frame: 0 };
const saveStateRuntime = { timer: null };
const handleLinePool = [];
const dotPool = Object.create(null);
const ANCHOR_POINT_RATIOS = {
  tl: [0, 0], tc: [0.5, 0], tr: [1, 0],
  cl: [0, 0.5], cc: [0.5, 0.5], cr: [1, 0.5],
  bl: [0, 1], bc: [0.5, 1], br: [1, 1],
};

function scheduleRender() {
  if (renderState.frame) return;
  renderState.frame = requestAnimationFrame(() => {
    renderState.frame = 0;
    render();
  });
}

function saveStateDebounced(delay = 180) {
  if (saveStateRuntime.timer) clearTimeout(saveStateRuntime.timer);
  saveStateRuntime.timer = setTimeout(() => {
    saveStateRuntime.timer = null;
    saveState();
  }, delay);
}

// ─── Dragging (SVG dots) ────────────────────────────────────────────
let dragTarget = null;

function getEndpointAnchorBase(which) {
  const el = which === 'start' ? anchorEndEl : anchorStartEl;
  const rect = el.getBoundingClientRect();
  const anchorKey = (which === 'start' ? els.startAnchorPoint.value : els.endAnchorPoint.value) || 'cc';
  const [ax, ay] = ANCHOR_POINT_RATIOS[anchorKey] || ANCHOR_POINT_RATIOS.cc;
  return {
    x: rect.left + rect.width * ax,
    y: rect.top + rect.height * ay,
  };
}

function getAnchoredEndpoints() {
  const startBase = getEndpointAnchorBase('start');
  const endBase = getEndpointAnchorBase('end');
  return {
    startX: startBase.x + state.startPos.x,
    startY: startBase.y + state.startPos.y,
    endX: endBase.x + state.endPos.x,
    endY: endBase.y + state.endPos.y,
  };
}

function getOffsetFromControls(which) {
  const xSide = which === 'start' ? els.startOffsetXSide.value : els.endOffsetXSide.value;
  const ySide = which === 'start' ? els.startOffsetYSide.value : els.endOffsetYSide.value;
  const xValueRaw = which === 'start' ? els.startOffsetXValue.value : els.endOffsetXValue.value;
  const yValueRaw = which === 'start' ? els.startOffsetYValue.value : els.endOffsetYValue.value;
  const xValue = Math.max(0, parseInt(xValueRaw) || 0);
  const yValue = Math.max(0, parseInt(yValueRaw) || 0);
  return {
    x: xSide === 'left' ? xValue : -xValue,
    y: ySide === 'top' ? yValue : -yValue,
  };
}

function syncControlsFromOffset(which, offset) {
  const xSideEl = which === 'start' ? els.startOffsetXSide : els.endOffsetXSide;
  const ySideEl = which === 'start' ? els.startOffsetYSide : els.endOffsetYSide;
  const xValueEl = which === 'start' ? els.startOffsetXValue : els.endOffsetXValue;
  const yValueEl = which === 'start' ? els.startOffsetYValue : els.endOffsetYValue;
  xSideEl.value = offset.x >= 0 ? 'left' : 'right';
  ySideEl.value = offset.y >= 0 ? 'top' : 'bottom';
  xValueEl.value = Math.abs(Math.round(offset.x));
  yValueEl.value = Math.abs(Math.round(offset.y));
}

function setActiveAnchorButtons(which) {
  const grid = document.getElementById(which + 'AnchorGrid');
  const value = which === 'start' ? els.startAnchorPoint.value : els.endAnchorPoint.value;
  grid.querySelectorAll('.anchor-dot').forEach(dot => {
    dot.classList.toggle('active', dot.dataset.anchorPoint === value);
  });
}

function getControlAnchor(key) {
  const { startX: sx, startY: sy, endX: ex, endY: ey } = getAnchoredEndpoints();
  const c = state.values[state.activeTab];
  const midX = (sx + ex) / 2, midY = (sy + ey) / 2;
  const loopX = midX + c.loopX, loopY = midY + c.loopY;
  const exitX = loopX + c.exitX, exitY = loopY + c.exitY;
  const map = {
    loop: { x: midX, y: midY },
    e1: { x: sx, y: sy },
    e2: { x: loopX, y: loopY },
    l1: { x: loopX, y: loopY },
    l2: { x: loopX, y: loopY },
    exit: { x: loopX, y: loopY },
    x1: { x: exitX, y: exitY },
    x2: { x: ex, y: ey },
  };
  return map[key];
}

function updateControlFromDrag(key, mx, my) {
  const anchor = getControlAnchor(key);
  const xKey = key + 'X', yKey = key + 'Y';
  const nx = Math.round(mx - anchor.x), ny = Math.round(my - anchor.y);
  state.values[state.activeTab][xKey] = nx;
  state.values[state.activeTab][yKey] = ny;
  const sx = document.getElementById('slider_' + xKey);
  const sy = document.getElementById('slider_' + yKey);
  const nx2 = document.getElementById('num_' + xKey);
  const ny2 = document.getElementById('num_' + yKey);
  if (sx) sx.value = nx;
  if (sy) sy.value = ny;
  if (nx2) nx2.value = nx;
  if (ny2) ny2.value = ny;
}

lineSvg.addEventListener('mousedown', e => {
  const el = e.target;
  if (!el.dataset || !el.dataset.dragType) return;
  e.preventDefault();
  dragTarget = { type: el.dataset.dragType, key: el.dataset.dragKey };
  document.body.classList.add('dragging');
});

document.addEventListener('mousemove', e => {
  if (!dragTarget) return;
  const mx = e.clientX, my = e.clientY;
  if (dragTarget.type === 'endpoint') {
    const base = getEndpointAnchorBase(dragTarget.key);
    const next = { x: Math.round(mx - base.x), y: Math.round(my - base.y) };
    if (dragTarget.key === 'start') state.startPos = next;
    else state.endPos = next;
    syncControlsFromOffset(dragTarget.key, next);
  } else {
    updateControlFromDrag(dragTarget.key, mx, my);
  }
  scheduleRender();
});

document.addEventListener('mouseup', () => {
  if (dragTarget) {
    dragTarget = null;
    document.body.classList.remove('dragging');
    saveStateDebounced(0);
  }
});

// ─── Section collapse ───────────────────────────────────────────────
function toggleSection(header) {
  header.parentElement.classList.toggle('collapsed');
}

// ─── Feature toggles ────────────────────────────────────────────────
function toggleFeature(key) {
  state.features[key] = !state.features[key];
  document.getElementById('toggle' + key.charAt(0).toUpperCase() + key.slice(1))
    .classList.toggle('on', state.features[key]);

  if (key === 'responsive' || key === 'scroll') {
    buildTabs();
    buildSliders();
  }

  const scrollBps = document.querySelectorAll('#scrollBpRow1, #scrollBpRow2');
  scrollBps.forEach(el => el.style.display = state.features.scroll ? '' : 'none');

  render();
  saveState();
}

function syncEndpointControls() {
  syncControlsFromOffset('start', state.startPos);
  syncControlsFromOffset('end', state.endPos);
  setActiveAnchorButtons('start');
  setActiveAnchorButtons('end');
}

function onAnchorConfigChange(which) {
  const offset = getOffsetFromControls(which);
  if (which === 'start') state.startPos = offset;
  else state.endPos = offset;
  scheduleRender();
  saveStateDebounced();
}

function onAnchorPointSelect(which, point) {
  if (which === 'start') els.startAnchorPoint.value = point;
  else els.endAnchorPoint.value = point;
  setActiveAnchorButtons(which);
  scheduleRender();
  saveStateDebounced();
}

// ─── Breakpoints ────────────────────────────────────────────────────
function getBreakpoints() {
  return {
    MIN_WIDTH: parseInt(els.bpMinWidth.value) || 992,
    GROW_START: parseInt(els.bpGrowStart.value) || 1280,
    MAX_WIDTH: parseInt(els.bpMaxWidth.value) || 1920,
    SCROLL_START: parseInt(els.bpScrollStart.value) || 250,
    SCROLL_HIDE: parseInt(els.bpScrollHide.value) || 180,
  };
}

function onBreakpointChange() {
  buildTabs();
  render();
  saveState();
}

// ─── Tabs ───────────────────────────────────────────────────────────
function buildTabs() {
  const bp = getBreakpoints();
  let tabs = [];

  if (state.features.responsive) {
    tabs.push({ id: 'min', label: `Min (${bp.MIN_WIDTH}px)` });
    tabs.push({ id: 'max', label: `Max (${bp.MAX_WIDTH}px)` });
  } else {
    tabs.push({ id: 'min', label: 'Base' });
  }

  if (state.features.scroll) {
    tabs.push({ id: 'scroll', label: 'Scroll' });
  }

  if (!tabs.find(t => t.id === state.activeTab)) {
    state.activeTab = tabs[0].id;
  }

  tabsContainer.innerHTML = tabs.map(t =>
    `<div class="tab ${t.id === state.activeTab ? 'active' : ''}" onclick="switchTab('${t.id}')">${t.label}</div>`
  ).join('');
}

function switchTab(id) {
  state.activeTab = id;
  buildTabs();
  buildSliders();
  render();
  saveState();
}

// ─── Sliders ────────────────────────────────────────────────────────
function buildSliders() {
  const vals = state.values[state.activeTab];
  let html = '';

  PARAM_GROUPS.forEach(group => {
    html += `<div class="slider-group">`;
    html += `<div class="slider-group-title"><span class="dot" style="background:${group.color}"></span>${group.name}</div>`;

    group.keys.forEach(key => {
      const axis = key.endsWith('X') ? 'X' : 'Y';
      const val = vals[key];
      html += `<div class="slider-row">
        <label>${axis}</label>
        <input type="range" min="-200" max="200" step="1" value="${val}"
          id="slider_${key}" oninput="onSliderInput('${key}', this.value)">
        <input type="number" min="-200" max="200" step="1" value="${val}"
          id="num_${key}" onchange="onNumInput('${key}', this.value)">
      </div>`;
    });

    html += `</div>`;
  });

  slidersContainer.innerHTML = html;
}

function onSliderInput(key, value) {
  const v = parseInt(value);
  state.values[state.activeTab][key] = v;
  document.getElementById('num_' + key).value = v;
  scheduleRender();
  saveStateDebounced();
}

function onNumInput(key, value) {
  const v = parseInt(value);
  state.values[state.activeTab][key] = v;
  document.getElementById('slider_' + key).value = v;
  scheduleRender();
  saveStateDebounced();
}

// ─── Style controls ─────────────────────────────────────────────────
function getStyleConfig() {
  return {
    color1: els.styleColor1.value,
    color2: els.styleColor2.value,
    strokeWidth: parseFloat(els.styleStrokeWidth.value),
    dashLen: parseInt(els.styleDashLen.value),
    dashGap: parseInt(els.styleDashGap.value),
    arrowSize: parseInt(els.styleArrowSize.value),
    arrowAngle: parseInt(els.styleArrowAngle.value),
    arrowColor: els.styleArrowColor.value,
  };
}

function onStyleChange() {
  // Sync slider/number pairs
  const pairs = [
    [els.styleStrokeWidth, els.styleStrokeWidthNum],
    [els.styleDashLen, els.styleDashLenNum],
    [els.styleDashGap, els.styleDashGapNum],
    [els.styleArrowSize, els.styleArrowSizeNum],
    [els.styleArrowAngle, els.styleArrowAngleNum],
  ];
  pairs.forEach(([sliderEl, numEl]) => {
    numEl.value = sliderEl.value;
  });
  scheduleRender();
  saveStateDebounced();
}

function syncStyleSlider(which) {
  const map = {
    strokeWidth: [els.styleStrokeWidth, els.styleStrokeWidthNum],
    dashLen: [els.styleDashLen, els.styleDashLenNum],
    dashGap: [els.styleDashGap, els.styleDashGapNum],
    arrowSize: [els.styleArrowSize, els.styleArrowSizeNum],
    arrowAngle: [els.styleArrowAngle, els.styleArrowAngleNum],
  };
  const [sliderEl, numEl] = map[which];
  sliderEl.value = numEl.value;
  scheduleRender();
  saveStateDebounced();
}

// ─── Draw animation controls ────────────────────────────────────────
function getDrawConfig() {
  const useGradient = els.drawUseGradient.checked;
  return {
    duration: parseFloat(els.drawDuration.value),
    useGradient,
    color: useGradient ? '' : els.drawColor.value,
    strokeWidth: parseFloat(els.drawStrokeWidth.value),
    opacity: parseFloat(els.drawOpacity.value),
  };
}

function onDrawStyleChange() {
  const useGradient = els.drawUseGradient.checked;
  els.drawColor.disabled = useGradient;
  const pairs = [
    [els.drawDuration, els.drawDurationNum],
    [els.drawStrokeWidth, els.drawStrokeWidthNum],
    [els.drawOpacity, els.drawOpacityNum],
  ];
  pairs.forEach(([sliderEl, numEl]) => {
    numEl.value = sliderEl.value;
  });
  saveStateDebounced();
}

function syncDrawSlider(which) {
  const map = {
    duration: [els.drawDuration, els.drawDurationNum],
    strokeWidth: [els.drawStrokeWidth, els.drawStrokeWidthNum],
    opacity: [els.drawOpacity, els.drawOpacityNum],
  };
  const [sliderEl, numEl] = map[which];
  sliderEl.value = numEl.value;
  saveStateDebounced();
}

function previewDraw() {
  const style = getStyleConfig();
  const draw = getDrawConfig();
  const pathLen = mainPath.getTotalLength();

  // Set draw-phase style
  if (draw.color) {
    mainPath.setAttribute('stroke', draw.color);
  }
  mainPath.setAttribute('stroke-width', draw.strokeWidth.toString());
  mainPath.style.opacity = draw.opacity.toString();
  arrowPath.style.opacity = '0';

  mainPath.style.transition = 'none';
  mainPath.style.strokeDasharray = `${pathLen}`;
  mainPath.style.strokeDashoffset = `${pathLen}`;
  mainPath.getBoundingClientRect(); // force reflow

  mainPath.style.transition = `stroke-dashoffset ${draw.duration}s ease-out`;
  mainPath.style.strokeDashoffset = '0';

  setTimeout(() => {
    mainPath.style.transition = 'none';
    mainPath.setAttribute('stroke', 'url(#lineGradient)');
    mainPath.setAttribute('stroke-width', style.strokeWidth.toString());
    mainPath.style.opacity = '1';
    mainPath.style.strokeDasharray = `${style.dashLen} ${style.dashGap}`;
    mainPath.style.strokeDashoffset = '0';

    arrowPath.style.transition = 'opacity 0.3s ease-out';
    arrowPath.style.opacity = '1';
  }, draw.duration * 1000 + 50);
}

function ensureHandleLine(index) {
  if (!handleLinePool[index]) {
    const line = document.createElementNS(SVG_NS, 'line');
    line.setAttribute('stroke-width', '1');
    line.setAttribute('stroke-dasharray', '3 3');
    line.setAttribute('opacity', '0.5');
    handleLinesG.appendChild(line);
    handleLinePool[index] = line;
  }
  return handleLinePool[index];
}

function ensureDot(dotKey, dragType, dragKey, label) {
  if (!dotPool[dotKey]) {
    const circle = document.createElementNS(SVG_NS, 'circle');
    circle.style.pointerEvents = 'all';
    circle.style.cursor = 'grab';
    circle.dataset.dragType = dragType;
    circle.dataset.dragKey = dragKey;
    const text = document.createElementNS(SVG_NS, 'text');
    text.setAttribute('font-size', '10');
    text.setAttribute('font-family', '-apple-system, sans-serif');
    text.setAttribute('font-weight', '600');
    text.setAttribute('opacity', '0.7');
    text.style.pointerEvents = 'none';
    text.textContent = label;
    debugDotsG.appendChild(circle);
    debugDotsG.appendChild(text);
    dotPool[dotKey] = { circle, text };
  }
  return dotPool[dotKey];
}

function updateDot(dot, cfg) {
  dot.circle.style.display = '';
  dot.text.style.display = '';
  dot.circle.setAttribute('cx', cfg.x);
  dot.circle.setAttribute('cy', cfg.y);
  dot.circle.setAttribute('r', cfg.r);
  dot.circle.setAttribute('fill', cfg.fill);
  dot.circle.setAttribute('stroke', cfg.stroke);
  dot.circle.setAttribute('stroke-width', cfg.sw);
  dot.text.setAttribute('x', (parseFloat(cfg.x) + 10).toString());
  dot.text.setAttribute('y', (parseFloat(cfg.y) - 10).toString());
  dot.text.setAttribute('fill', cfg.fill);
}

function hideDot(dot) {
  dot.circle.style.display = 'none';
  dot.text.style.display = 'none';
}

// ─── Rendering ──────────────────────────────────────────────────────
function render() {
  const controls = state.values[state.activeTab];
  const style = getStyleConfig();

  // Start/end positions from anchor elements + offsets.
  const { startX, startY, endX, endY } = getAnchoredEndpoints();

  // Update gradient
  lineGradient.setAttribute('x1', endX.toString());
  lineGradient.setAttribute('y1', endY.toString());
  lineGradient.setAttribute('x2', startX.toString());
  lineGradient.setAttribute('y2', startY.toString());
  lineGradientStartStop.setAttribute('stop-color', style.color1);
  lineGradientEndStop.setAttribute('stop-color', style.color2);

  // Compute all points
  const loopX = (startX + endX) / 2 + controls.loopX;
  const loopY = (startY + endY) / 2 + controls.loopY;
  const entry1X = startX + controls.e1X;
  const entry1Y = startY + controls.e1Y;
  const entry2X = loopX + controls.e2X;
  const entry2Y = loopY + controls.e2Y;
  const loopCp1X = loopX + controls.l1X;
  const loopCp1Y = loopY + controls.l1Y;
  const loopCp2X = loopX + controls.l2X;
  const loopCp2Y = loopY + controls.l2Y;
  const loopExitX = loopX + controls.exitX;
  const loopExitY = loopY + controls.exitY;
  const exit1X = loopExitX + controls.x1X;
  const exit1Y = loopExitY + controls.x1Y;
  const exit2X = endX + controls.x2X;
  const exit2Y = endY + controls.x2Y;

  const pathD = `M ${startX} ${startY} C ${entry1X} ${entry1Y}, ${entry2X} ${entry2Y}, ${loopX} ${loopY} C ${loopCp1X} ${loopCp1Y}, ${loopCp2X} ${loopCp2Y}, ${loopExitX} ${loopExitY} C ${exit1X} ${exit1Y}, ${exit2X} ${exit2Y}, ${endX} ${endY}`;

  mainPath.setAttribute('d', pathD);
  mainPath.setAttribute('stroke-width', style.strokeWidth.toString());
  mainPath.style.strokeDasharray = `${style.dashLen} ${style.dashGap}`;

  // Arrow
  const arrowAngleRad = (style.arrowAngle * Math.PI) / 180;
  const tangentAngle = Math.atan2(exit2Y - endY, exit2X - endX);
  const a1x = endX + style.arrowSize * Math.cos(tangentAngle - arrowAngleRad);
  const a1y = endY + style.arrowSize * Math.sin(tangentAngle - arrowAngleRad);
  const a2x = endX + style.arrowSize * Math.cos(tangentAngle + arrowAngleRad);
  const a2y = endY + style.arrowSize * Math.sin(tangentAngle + arrowAngleRad);

  arrowPath.setAttribute('d', `M ${a1x} ${a1y} L ${endX} ${endY} L ${a2x} ${a2y}`);
  arrowPath.setAttribute('stroke', style.arrowColor);
  arrowPath.setAttribute('stroke-width', style.strokeWidth.toString());
  arrowPath.setAttribute('stroke-dasharray', `${style.dashLen} ${style.dashGap}`);

  // Control points data
  const controlPoints = [
    { name: 'e1', key: 'e1', x: entry1X, y: entry1Y, color: PARAM_GROUPS[1].color, anchor: { x: startX, y: startY } },
    { name: 'e2', key: 'e2', x: entry2X, y: entry2Y, color: PARAM_GROUPS[2].color, anchor: { x: loopX, y: loopY } },
    { name: 'loop', key: 'loop', x: loopX, y: loopY, color: PARAM_GROUPS[0].color },
    { name: 'l1', key: 'l1', x: loopCp1X, y: loopCp1Y, color: PARAM_GROUPS[3].color, anchor: { x: loopX, y: loopY } },
    { name: 'l2', key: 'l2', x: loopCp2X, y: loopCp2Y, color: PARAM_GROUPS[4].color, anchor: { x: loopX, y: loopY } },
    { name: 'exit', key: 'exit', x: loopExitX, y: loopExitY, color: PARAM_GROUPS[5].color },
    { name: 'x1', key: 'x1', x: exit1X, y: exit1Y, color: PARAM_GROUPS[6].color, anchor: { x: loopExitX, y: loopExitY } },
    { name: 'x2', key: 'x2', x: exit2X, y: exit2Y, color: PARAM_GROUPS[7].color, anchor: { x: endX, y: endY } },
  ];

  // Handle lines
  const anchoredControls = controlPoints.filter(p => p.anchor);
  if (state.features.handles) {
    anchoredControls.forEach((p, index) => {
      const line = ensureHandleLine(index);
      line.style.display = '';
      line.setAttribute('x1', p.anchor.x);
      line.setAttribute('y1', p.anchor.y);
      line.setAttribute('x2', p.x);
      line.setAttribute('y2', p.y);
      line.setAttribute('stroke', p.color);
    });
    for (let i = anchoredControls.length; i < handleLinePool.length; i++) {
      handleLinePool[i].style.display = 'none';
    }
  } else {
    handleLinePool.forEach(line => { line.style.display = 'none'; });
  }

  // Start/end endpoint dots (draggable handles)
  const startDot = ensureDot('endpoint_start', 'endpoint', 'start', 'start');
  const endDot = ensureDot('endpoint_end', 'endpoint', 'end', 'end');
  if (state.features.endpoints) {
    updateDot(startDot, {
      x: startX.toString(), y: startY.toString(), r: '8', fill: '#98CB4F', stroke: '#fff', sw: '2'
    });
    updateDot(endDot, {
      x: endX.toString(), y: endY.toString(), r: '8', fill: '#41A0AA', stroke: '#fff', sw: '2'
    });
  } else {
    hideDot(startDot);
    hideDot(endDot);
  }

  // Control point dots (toggleable, also draggable)
  controlPoints.forEach(p => {
    const dot = ensureDot(`control_${p.key}`, 'control', p.key, p.name);
    if (!state.features.dots) {
      hideDot(dot);
      return;
    }
    updateDot(dot, {
      x: p.x.toString(), y: p.y.toString(), r: '6', fill: p.color, stroke: '#0d0f1a', sw: '1.5'
    });
  });
}

// ─── Copy / Export ──────────────────────────────────────────────────
function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg || 'Copied!';
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 1500);
}

function copyValues() {
  const vals = state.values[state.activeTab];
  navigator.clipboard.writeText(JSON.stringify(vals, null, 2)).then(() => showToast('Values copied!'));
}

function copyAll() {
  const out = {};
  if (state.features.responsive) {
    out.valuesAtMin = state.values.min;
    out.valuesAtMax = state.values.max;
  } else {
    out.values = state.values.min;
  }
  if (state.features.scroll) {
    out.valuesAtScroll = state.values.scroll;
  }
  navigator.clipboard.writeText(JSON.stringify(out, null, 2)).then(() => showToast('All values copied!'));
}

function generateJS(format = 'ts') {
  const isTs = format === 'ts';
  const bp = getBreakpoints();
  const style = getStyleConfig();
  const draw = getDrawConfig();
  const hasResponsive = state.features.responsive;
  const hasScroll = state.features.scroll;

  const fmtObj = (obj) => {
    const entries = Object.entries(obj).map(([k,v]) => `${k}: ${v}`).join(', ');
    return `{ ${entries} }`;
  };

  const typeBlock = isTs ? `
export interface LeaderLineOptions {
  color?: string;
  gradientColors?: [string, string];
  strokeWidth?: number;
  dashArray?: string;
  arrowSize?: number;
  drawDuration?: number;
  drawColor?: string;
  drawStrokeWidth?: number;
  drawOpacity?: number;
  startOffset?: [number, number];
  endAnchor?: [number, number];
  observeMutations?: boolean;
}

export interface LeaderLineInstance {
  remove: () => void;
  position: () => void;
}
` : '';

  const defaultOptionsDecl = isTs
    ? 'const DEFAULT_OPTIONS: Required<LeaderLineOptions> = {'
    : 'const DEFAULT_OPTIONS = {';

  const createFnSig = isTs
    ? `export function createLeaderLine(
  startElement: Element,
  endElement: Element,
  options: LeaderLineOptions = {}
): LeaderLineInstance {`
    : `export function createLeaderLine(startElement, endElement, options = {}) {`;

  const lerpSig = isTs
    ? '  const lerp = (start: number, end: number, progress: number) => {'
    : '  const lerp = (start, end, progress) => {';

  const findScrollParentSig = isTs
    ? '  const findScrollParent = (element: Element): Element | Window => {'
    : '  const findScrollParent = (element) => {';

  const scrollParentAdd = isTs
    ? "    (scrollParent as Element).addEventListener('scroll', handler, passiveOptions);"
    : "    scrollParent.addEventListener('scroll', handler, passiveOptions);";

  const scrollParentRemove = isTs
    ? "        (scrollParent as Element).removeEventListener('scroll', handler);"
    : "        scrollParent.removeEventListener('scroll', handler);";

  let code = `/**
 * Custom LeaderLine implementation
 * Generated by Arrowy - Leader Line Tuning Tool
 */
${typeBlock}
${defaultOptionsDecl}
  color: '${style.color1}',
  gradientColors: ['${style.color1}', '${style.color2}'],
  strokeWidth: ${style.strokeWidth},
  dashArray: '${style.dashLen} ${style.dashGap}',
  arrowSize: ${style.arrowSize},
  drawDuration: ${draw.duration},
  drawColor: '${draw.color}',
  drawStrokeWidth: ${draw.strokeWidth},
  drawOpacity: ${draw.opacity},
  startOffset: [20, 20],
  endAnchor: [0.5, 0.5],
  observeMutations: false,
};

${createFnSig}
  const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
  const normalizeDashArray = (value) => {
    if (typeof value !== 'string') return DEFAULT_OPTIONS.dashArray;
    const match = value.trim().match(/^(\\d+(?:\\.\\d+)?)\\s+(\\d+(?:\\.\\d+)?)$/);
    return match ? \`\${match[1]} \${match[2]}\` : DEFAULT_OPTIONS.dashArray;
  };
  const normalizeTuple = (value, fallback) => {
    if (!Array.isArray(value) || value.length !== 2) return fallback;
    const a = Number(value[0]);
    const b = Number(value[1]);
    if (!Number.isFinite(a) || !Number.isFinite(b)) return fallback;
    return [a, b];
  };
  const rawOpts = { ...DEFAULT_OPTIONS, ...options };
  const opts = {
    ...rawOpts,
    gradientColors: Array.isArray(rawOpts.gradientColors) && rawOpts.gradientColors.length === 2
      ? [String(rawOpts.gradientColors[0]), String(rawOpts.gradientColors[1])]
      : DEFAULT_OPTIONS.gradientColors,
    strokeWidth: Math.max(0.5, Number(rawOpts.strokeWidth) || DEFAULT_OPTIONS.strokeWidth),
    dashArray: normalizeDashArray(rawOpts.dashArray),
    arrowSize: Math.max(1, Number(rawOpts.arrowSize) || DEFAULT_OPTIONS.arrowSize),
    drawDuration: Math.max(0, Number(rawOpts.drawDuration) || DEFAULT_OPTIONS.drawDuration),
    drawColor: typeof rawOpts.drawColor === 'string' ? rawOpts.drawColor : DEFAULT_OPTIONS.drawColor,
    drawStrokeWidth: Math.max(0.5, Number(rawOpts.drawStrokeWidth) || DEFAULT_OPTIONS.drawStrokeWidth),
    drawOpacity: clamp(Number(rawOpts.drawOpacity), 0, 1),
    startOffset: normalizeTuple(rawOpts.startOffset, DEFAULT_OPTIONS.startOffset),
    endAnchor: normalizeTuple(rawOpts.endAnchor, DEFAULT_OPTIONS.endAnchor),
    observeMutations: Boolean(rawOpts.observeMutations),
  };

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  const uniqueId = \`leader-line-\${Date.now()}-\${Math.random().toString(36).substr(2, 9)}\`;

  svg.setAttribute('class', 'custom-leader-line');
  svg.style.cssText = \`
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 1000; overflow: visible;
  \`;

  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
  gradient.setAttribute('id', \`\${uniqueId}-gradient\`);
  gradient.setAttribute('gradientUnits', 'userSpaceOnUse');

  const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
  stop1.setAttribute('offset', '0%');
  stop1.setAttribute('stop-color', opts.gradientColors[0]);
  const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
  stop2.setAttribute('offset', '100%');
  stop2.setAttribute('stop-color', opts.gradientColors[1]);

  gradient.appendChild(stop1);
  gradient.appendChild(stop2);
  defs.appendChild(gradient);
  svg.appendChild(defs);

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke', \`url(#\${uniqueId}-gradient)\`);
  path.setAttribute('stroke-width', opts.strokeWidth.toString());
  path.setAttribute('stroke-linecap', 'round');
  path.setAttribute('stroke-linejoin', 'round');
  svg.appendChild(path);

  const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  arrow.setAttribute('fill', 'none');
  arrow.setAttribute('stroke', opts.gradientColors[0]);
  arrow.setAttribute('stroke-width', opts.strokeWidth.toString());
  arrow.setAttribute('stroke-linecap', 'round');
  arrow.setAttribute('stroke-linejoin', 'round');
  arrow.style.opacity = '0';
  svg.appendChild(arrow);

  document.body.appendChild(svg);

  let needsDrawAnimation = true;
  let wasHidden = false;
  let destroyed = false;
  let frameId = 0;
  let drawTimeoutId = 0;
`;

  if (hasResponsive) {
    code += `
  const valuesAtMin = ${fmtObj(state.values.min)};
  const valuesAtMax = ${fmtObj(state.values.max)};
`;
  } else {
    code += `
  const baseValues = ${fmtObj(state.values.min)};
`;
  }

  if (hasScroll) {
    code += `  const valuesAtScroll = ${fmtObj(state.values.scroll)};
`;
  }

  if (hasResponsive) {
    code += `
  const MIN_WIDTH = ${bp.MIN_WIDTH};
  const GROW_START = ${bp.GROW_START};
  const MAX_WIDTH = ${bp.MAX_WIDTH};
`;
  } else {
    code += `
  const MIN_WIDTH = ${bp.MIN_WIDTH};
`;
  }

  if (hasScroll) {
    code += `  const SCROLL_START_INTERPOLATE = ${bp.SCROLL_START};
  const SCROLL_HIDE_THRESHOLD = ${bp.SCROLL_HIDE};
`;
  }

  code += `
${lerpSig}
    return Math.round(start + (end - start) * progress);
  };
`;

  if (hasResponsive) {
    code += `
  const getResponsiveValues = () => {
    const width = window.innerWidth;
    if (width < MIN_WIDTH || width <= GROW_START) return { ...valuesAtMin };
    const progress = Math.min((width - GROW_START) / (MAX_WIDTH - GROW_START), 1);
    return {
${PARAM_KEYS.map(k => `      ${k}: lerp(valuesAtMin.${k}, valuesAtMax.${k}, progress),`).join('\n')}
    };
  };
`;
  }

  code += `
  function updatePosition() {
    if (destroyed) return;
    if (window.innerWidth < MIN_WIDTH) {
      svg.style.display = 'none';
      wasHidden = true;
      return;
    }

    const startRect = startElement.getBoundingClientRect();
    if (startRect.width === 0 || startRect.height === 0) {
      svg.style.display = 'none';
      wasHidden = true;
      return;
    }
`;

  if (hasScroll) {
    code += `
    if (startRect.top < SCROLL_HIDE_THRESHOLD) {
      svg.style.display = 'none';
      wasHidden = true;
      return;
    }

    if (wasHidden) {
      if (startRect.top > SCROLL_START_INTERPOLATE) {
        wasHidden = false;
        needsDrawAnimation = true;
        arrow.style.opacity = '0';
      } else {
        svg.style.display = 'none';
        return;
      }
    }
`;
  } else {
    code += `
    if (wasHidden) {
      wasHidden = false;
      needsDrawAnimation = true;
      arrow.style.opacity = '0';
    }
`;
  }

  code += `
    svg.style.display = '';
    svg.style.opacity = '1';
`;

  if (hasScroll) {
    code += `
    let scrollProgress = 0;
    if (startRect.top < SCROLL_START_INTERPOLATE) {
      scrollProgress = Math.min(
        Math.max((SCROLL_START_INTERPOLATE - startRect.top) / (SCROLL_START_INTERPOLATE - SCROLL_HIDE_THRESHOLD), 0), 1
      );
    }
    svg.style.opacity = (1 - scrollProgress * 0.7).toString();
`;
  }

  if (hasResponsive) {
    code += `
    const baseValues = getResponsiveValues();
`;
  }

  if (hasScroll) {
    code += `    const controls = {
${PARAM_KEYS.map(k => `      ${k}: lerp(baseValues.${k}, valuesAtScroll.${k}, scrollProgress),`).join('\n')}
    };
`;
  } else if (hasResponsive) {
    code += `    const controls = baseValues;
`;
  } else {
    code += `    const controls = baseValues;
`;
  }

  const arrowAngleRad = `(${style.arrowAngle} * Math.PI / 180)`;

  code += `
    const startX = startRect.left + opts.startOffset[0];
    const startY = startRect.top + opts.startOffset[1];
    const endRect = endElement.getBoundingClientRect();
    const endX = endRect.left + endRect.width * opts.endAnchor[0];
    const endY = endRect.top + endRect.height * opts.endAnchor[1];

    gradient.setAttribute('x1', endX.toString());
    gradient.setAttribute('y1', endY.toString());
    gradient.setAttribute('x2', startX.toString());
    gradient.setAttribute('y2', startY.toString());

    const loopX = (startX + endX) / 2 + controls.loopX;
    const loopY = (startY + endY) / 2 + controls.loopY;
    const entry1X = startX + controls.e1X;
    const entry1Y = startY + controls.e1Y;
    const entry2X = loopX + controls.e2X;
    const entry2Y = loopY + controls.e2Y;
    const loopCp1X = loopX + controls.l1X;
    const loopCp1Y = loopY + controls.l1Y;
    const loopCp2X = loopX + controls.l2X;
    const loopCp2Y = loopY + controls.l2Y;
    const loopExitX = loopX + controls.exitX;
    const loopExitY = loopY + controls.exitY;
    const exit1X = loopExitX + controls.x1X;
    const exit1Y = loopExitY + controls.x1Y;
    const exit2X = endX + controls.x2X;
    const exit2Y = endY + controls.x2Y;

    const pathD = \`M \${startX} \${startY} C \${entry1X} \${entry1Y}, \${entry2X} \${entry2Y}, \${loopX} \${loopY} C \${loopCp1X} \${loopCp1Y}, \${loopCp2X} \${loopCp2Y}, \${loopExitX} \${loopExitY} C \${exit1X} \${exit1Y}, \${exit2X} \${exit2Y}, \${endX} \${endY}\`;
    path.setAttribute('d', pathD);

    if (needsDrawAnimation) {
      needsDrawAnimation = false;
      const pathLength = path.getTotalLength();
      if (opts.drawColor) path.setAttribute('stroke', opts.drawColor);
      path.setAttribute('stroke-width', opts.drawStrokeWidth.toString());
      path.style.opacity = opts.drawOpacity.toString();
      path.style.transition = 'none';
      path.style.strokeDasharray = \`\${pathLength}\`;
      path.style.strokeDashoffset = \`\${pathLength}\`;
      path.getBoundingClientRect();
      path.style.transition = \`stroke-dashoffset \${opts.drawDuration}s ease-out\`;
      path.style.strokeDashoffset = '0';
      drawTimeoutId = window.setTimeout(() => {
        if (destroyed) return;
        path.style.transition = 'none';
        path.setAttribute('stroke', \`url(#\${uniqueId}-gradient)\`);
        path.setAttribute('stroke-width', opts.strokeWidth.toString());
        path.style.opacity = '1';
        path.style.strokeDasharray = opts.dashArray;
        path.style.strokeDashoffset = '0';
        arrow.setAttribute('stroke-dasharray', opts.dashArray);
        arrow.style.transition = 'opacity 0.3s ease-out';
        arrow.style.opacity = '1';
      }, opts.drawDuration * 1000 + 50);
    }

    const arrowAngle = ${arrowAngleRad};
    const tangentAngle = Math.atan2(exit2Y - endY, exit2X - endX);
    const a1x = endX + opts.arrowSize * Math.cos(tangentAngle - arrowAngle);
    const a1y = endY + opts.arrowSize * Math.sin(tangentAngle - arrowAngle);
    const a2x = endX + opts.arrowSize * Math.cos(tangentAngle + arrowAngle);
    const a2y = endY + opts.arrowSize * Math.sin(tangentAngle + arrowAngle);
    arrow.setAttribute('d', \`M \${a1x} \${a1y} L \${endX} \${endY} L \${a2x} \${a2y}\`);
  }

  const scheduleUpdate = () => {
    if (destroyed || frameId) return;
    frameId = requestAnimationFrame(() => {
      frameId = 0;
      updatePosition();
    });
  };

  updatePosition();

  const handler = () => scheduleUpdate();

${findScrollParentSig}
    let parent = element.parentElement;
    while (parent) {
      const style = getComputedStyle(parent);
      if (style.overflow === 'auto' || style.overflow === 'scroll' ||
        style.overflowY === 'auto' || style.overflowY === 'scroll') return parent;
      parent = parent.parentElement;
    }
    return window;
  };

  const scrollParent = findScrollParent(startElement);
  const passiveOptions = { passive: true };
  window.addEventListener('resize', handler);
  if (scrollParent === window) {
    window.addEventListener('scroll', handler, passiveOptions);
  } else {
${scrollParentAdd}
  }

  const resizeObserver = new ResizeObserver(() => scheduleUpdate());
  resizeObserver.observe(startElement);
  resizeObserver.observe(endElement);
  const mutationObserver = opts.observeMutations
    ? new MutationObserver(() => scheduleUpdate())
    : null;
  if (mutationObserver) {
    mutationObserver.observe(document.body, { attributes: true, childList: true, subtree: true });
  }

  return {
    remove: () => {
      if (destroyed) return;
      destroyed = true;
      if (frameId) {
        cancelAnimationFrame(frameId);
        frameId = 0;
      }
      if (drawTimeoutId) {
        clearTimeout(drawTimeoutId);
      }
      window.removeEventListener('resize', handler);
      if (scrollParent !== window) {
${scrollParentRemove}
      } else {
        window.removeEventListener('scroll', handler);
      }
      resizeObserver.disconnect();
      if (mutationObserver) mutationObserver.disconnect();
      svg.remove();
    },
    position: scheduleUpdate,
  };
}

export function useLeaderLine() {
  return { createLeaderLine };
}
`;

  return code;
}

const MINIFY_BUNDLE_URL = 'https://cdn.jsdelivr.net/npm/terser@5.39.0/dist/bundle.min.js';
let terserBundleLoad = null;
let currentGeneratedCode = '';
let currentCodeMode = 'readable';
let codeGenerationRunId = 0;

function ensureMinifierLoaded() {
  if (window.Terser) return Promise.resolve();
  if (terserBundleLoad) return terserBundleLoad;
  terserBundleLoad = new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = MINIFY_BUNDLE_URL;
    script.async = true;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error('Failed to load minifier'));
    document.head.appendChild(script);
  });
  return terserBundleLoad;
}

async function generateMinifiedJS() {
  const source = generateJS('js');
  try {
    await ensureMinifierLoaded();
    const result = await window.Terser.minify(source, {
      module: true,
      compress: true,
      mangle: true,
      format: { comments: false }
    });
    if (result && result.code) return result.code;
  } catch (error) {
    showToast('Minifier unavailable, copied readable JS');
  }
  return source;
}

function updateCodeModeButtons() {
  document.getElementById('codeModeReadable').classList.toggle('active', currentCodeMode === 'readable');
  document.getElementById('codeModeMinified').classList.toggle('active', currentCodeMode === 'minified');
}

async function renderCodeInModal(mode) {
  const runId = ++codeGenerationRunId;
  const codeBlock = document.getElementById('generatedCode');
  generatedCodeTitle.textContent = mode === 'minified' ? 'Generated Code (Minified JS)' : 'Generated Code (Readable JS)';
  codeBlock.textContent = mode === 'minified' ? 'Generating minified code...' : 'Generating code...';
  const code = mode === 'minified'
    ? await generateMinifiedJS()
    : generateJS('js');
  if (runId !== codeGenerationRunId) return;
  currentGeneratedCode = code;
  codeBlock.textContent = code;
}

function openCodeModal() {
  document.getElementById('modalBackdrop').classList.add('visible');
  setCodeMode('readable');
}

function setCodeMode(mode) {
  currentCodeMode = mode;
  updateCodeModeButtons();
  renderCodeInModal(mode);
}

function closeModal(e) {
  if (e && e.target !== document.getElementById('modalBackdrop') && e.type === 'click') return;
  document.getElementById('modalBackdrop').classList.remove('visible');
}

function copyGeneratedCode() {
  const content = currentGeneratedCode || document.getElementById('generatedCode').textContent;
  navigator.clipboard.writeText(content)
    .then(() => showToast('Code copied!'));
}

document.addEventListener('keydown', e => {
  if (e.key === 'Escape') closeModal();
});
window.addEventListener('resize', () => scheduleRender(), { passive: true });

// ─── Reset ──────────────────────────────────────────────────────────
function resetCurrent() {
  const tab = state.activeTab;
  state.values[tab] = { ...defaults[tab] };
  buildSliders();
  render();
  saveState();
  showToast('Reset to defaults');
}

// ─── LocalStorage ───────────────────────────────────────────────────
const STORAGE_KEY = 'arrowy_state';
const ANCHOR_DEMO_VERSION = 1;

function saveState() {
  const data = {
    anchorDemoVersion: ANCHOR_DEMO_VERSION,
    values: state.values,
    activeTab: state.activeTab,
    features: state.features,
    startPos: state.startPos,
    endPos: state.endPos,
    endpointAnchors: {
      start: els.startAnchorPoint.value,
      end: els.endAnchorPoint.value,
    },
    breakpoints: getBreakpoints(),
    style: {
      color1: els.styleColor1.value,
      color2: els.styleColor2.value,
      strokeWidth: els.styleStrokeWidth.value,
      dashLen: els.styleDashLen.value,
      dashGap: els.styleDashGap.value,
      arrowSize: els.styleArrowSize.value,
      arrowAngle: els.styleArrowAngle.value,
      arrowColor: els.styleArrowColor.value,
    },
    draw: {
      duration: els.drawDuration.value,
      useGradient: els.drawUseGradient.checked,
      color: els.drawColor.value,
      strokeWidth: els.drawStrokeWidth.value,
      opacity: els.drawOpacity.value,
    },
  };
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch(e) {}
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const d = JSON.parse(raw);

    if (d.values) {
      if (d.values.min) state.values.min = { ...defaults.min, ...d.values.min };
      if (d.values.max) state.values.max = { ...defaults.max, ...d.values.max };
      if (d.values.scroll) state.values.scroll = { ...defaults.scroll, ...d.values.scroll };
    }
    if (d.activeTab) state.activeTab = d.activeTab;
    if (d.features) state.features = { ...state.features, ...d.features };
    if (d.startPos) state.startPos = d.startPos;
    if (d.endPos) state.endPos = d.endPos;
    if (d.endpointAnchors) {
      if (d.endpointAnchors.start) els.startAnchorPoint.value = d.endpointAnchors.start;
      if (d.endpointAnchors.end) els.endAnchorPoint.value = d.endpointAnchors.end;
    }
    if (d.anchorDemoVersion !== ANCHOR_DEMO_VERSION) {
      // Reset endpoint offsets for first-run anchor demonstration.
      state.startPos = { x: 0, y: 0 };
      state.endPos = { x: 0, y: 0 };
    }
    const hasLegacyAbsolutePositions =
      Math.abs(state.startPos.x) > 320 || Math.abs(state.startPos.y) > 320 ||
      Math.abs(state.endPos.x) > 320 || Math.abs(state.endPos.y) > 320;
    if (hasLegacyAbsolutePositions) {
      const startBase = getEndpointAnchorBase('start');
      const endBase = getEndpointAnchorBase('end');
      state.startPos = {
        x: Math.round(state.startPos.x - startBase.x),
        y: Math.round(state.startPos.y - startBase.y),
      };
      state.endPos = {
        x: Math.round(state.endPos.x - endBase.x),
        y: Math.round(state.endPos.y - endBase.y),
      };
    }

    if (d.breakpoints) {
      els.bpMinWidth.value = d.breakpoints.MIN_WIDTH;
      els.bpGrowStart.value = d.breakpoints.GROW_START;
      els.bpMaxWidth.value = d.breakpoints.MAX_WIDTH;
      els.bpScrollStart.value = d.breakpoints.SCROLL_START;
      els.bpScrollHide.value = d.breakpoints.SCROLL_HIDE;
    }

    if (d.style) {
      const s = d.style;
      els.styleColor1.value = s.color1;
      els.styleColor2.value = s.color2;
      els.styleStrokeWidth.value = s.strokeWidth;
      els.styleStrokeWidthNum.value = s.strokeWidth;
      els.styleDashLen.value = s.dashLen;
      els.styleDashLenNum.value = s.dashLen;
      els.styleDashGap.value = s.dashGap;
      els.styleDashGapNum.value = s.dashGap;
      els.styleArrowSize.value = s.arrowSize;
      els.styleArrowSizeNum.value = s.arrowSize;
      els.styleArrowAngle.value = s.arrowAngle;
      els.styleArrowAngleNum.value = s.arrowAngle;
      els.styleArrowColor.value = s.arrowColor;
    }

    if (d.draw) {
      const dr = d.draw;
      els.drawDuration.value = dr.duration;
      els.drawDurationNum.value = dr.duration;
      els.drawUseGradient.checked = dr.useGradient;
      els.drawColor.value = dr.color;
      els.drawColor.disabled = dr.useGradient;
      els.drawStrokeWidth.value = dr.strokeWidth;
      els.drawStrokeWidthNum.value = dr.strokeWidth;
      els.drawOpacity.value = dr.opacity;
      els.drawOpacityNum.value = dr.opacity;
    }

    Object.keys(state.features).forEach(key => {
      const el = document.getElementById('toggle' + key.charAt(0).toUpperCase() + key.slice(1));
      if (el) el.classList.toggle('on', state.features[key]);
    });

    const scrollBps = document.querySelectorAll('#scrollBpRow1, #scrollBpRow2');
    scrollBps.forEach(el => el.style.display = state.features.scroll ? '' : 'none');
    syncEndpointControls();
  } catch(e) {}
}

// ─── Init ───────────────────────────────────────────────────────────
loadState();
syncEndpointControls();
buildTabs();
buildSliders();
render();
</script>
</body>
</html>
